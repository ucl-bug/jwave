import inspect

from plum.function import Function
from pygments import highlight
from pygments.formatters import HtmlFormatter
from pygments.lexers import PythonLexer


class Implementation(object):
  def __init__(self, name, params, docs):
    self.name = name
    self.params = params
    self.docs = docs

  def __str__(self):
    return self.__repr__()

  def __repr__(self):
    string = self._signature
    string += '\n\n'
    string += self.docs if self.docs else ''
    string += '\n'
    return string

  @staticmethod
  def param_to_string(names, types, defaults):
    namestring = f'{names}'
    typestring = ': '+str(types.__name__) if types != inspect._empty else ''
    defaultstring = f' = {defaults}' if defaults != inspect._empty else ''
    return namestring + typestring + defaultstring

  @property
  def _signature(self):
    string =  f'{self.name}('
    counter = 0
    for n in self.params.keys():
      thistype = self.params[n]._annotation
      default = self.params[n]._default
      string += ', ' if counter > 0 else ''
      string += self.param_to_string(n, thistype, default)
      counter += 1
    string += ')'
    string = highlight(string, PythonLexer(), HtmlFormatter())


    # Change outer <div> form class "highlight" to class "highlight language-python
    string = string.replace('<div class="highlight">', '<code class="highlight language-python">')
    # Remove <pre> and </pre>
    string = string.replace('<pre>', '').replace('</pre>', '')
    # Update <div> closing tag
    string = string.replace('</div>', '</code>')

    # Wrap around various containers
    string = '<h3 class="doc doc-heading operator-implementation">' + string + '</h3>'

    return string

def _extract_implementations(plum_func):
  name, function = plum_func
  implementations = []

  for signature, method in zip(function.methods.keys(), function.methods.values()):
    method = method[0].__wrapped__
    params = inspect.signature(method).parameters
    docs = inspect.getdoc(method)

    implementations.append(Implementation(name, params, docs))

  # Remove implementations with the same _signature
  # TODO: Understand why those duplicates exist at all..
  impl = {}
  for i in implementations:
    signature = i._signature
    if signature not in impl.keys():
      impl[signature] = i

  # Sort dictionary by key
  impl = {k: v for k, v in sorted(impl.items(), key=lambda item: item[0])}

  implementations = list(impl.values())
  return implementations


def mod_to_string(module_name, function=None):
  module_chain = module_name.split('.')
  mod, submodules = module_chain[0], module_chain[1:]
  # Get functions variables generated by the module
  mod = __import__(mod)
  for att in submodules:
    mod = getattr(mod, att)
  operators = set(inspect.getmembers(mod, lambda x: isinstance(x, Function)))

  if function is not None:
    # Keep only the operators whose first element is the same as the function
    operators = [op for op in operators if op[0] == function]

  # Sort operators by name
  def keyfun(op):
    func = op[1].methods
    func = func[func.keys()[0]][0].__wrapped__.__name__
    return func

  operators = [v for v in sorted(operators, key=lambda item: item[0])]

  implementations = list(map(_extract_implementations, operators))

  # Concatenate all implementations into a string
  text = ''
  for fun in implementations:
    #text += f'## `{fun[0].name}`\n\n'
    for i in fun:
      text += ''.join(str(i)) + '\n'
    #text += '\n<hr/>\n'
  return text

# -----------------------------------------------------------------------------
# define_env
# contains the macros definitions

def define_env(env):
    """
    This is the hook for defining variables, macros and filters

    - variables: the dictionary that contains the environment variables
    - macro: a decorator function, to declare a macro.
    - filter: a function with one of more arguments,
        used to perform a transformation
    """
    @env.macro
    def implementations(module: str, function=None):
      return mod_to_string(module, function)

    @env.macro
    def bar(x):
        return (2.3 * x) + 7

if __name__ == '__main__':
  _ = mod_to_string('jaxdf.operators.functions')
  print(_)
