{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"j-Wave","text":"<p>Fast and differentiable acoustic simulations in JAX</p> <p>j-Wave is a customizable Python simulator, written on top of the JAX library and the discretization framework JaxDF, designed for fast, parallelizable, and differentiable acoustic simulations.</p> <p>j-Wave solves both time-varying and time-harmonic forms of the wave equation, with support for multiple discretizations, including finite differences and Fourier spectral methods. Custom discretizations, including those based on neural networks, can also be utilized via the JaxDF framework.</p> <p>The use of the JAX library provides direct support for program transformations, such as automatic differentiation, Single-Program Multiple-Data (SPMD) parallelism, and just-in-time compilation.</p> <p>Following the philosophy of JAX, j-Wave is developed with the following principles in mind:</p> <ol> <li>Fully differentiable</li> <li>Fast through hardware-specific <code>jit</code> compilation</li> <li>Easy to run on GPUs and TPUs</li> <li>Easily customizable to support novel research ideas, including novel discretizations via <code>jaxdf</code></li> </ol> <p>Get started with j-Wave</p>"},{"location":"api_conversion.html","title":"<code>jwave.acoustics.conversion</code>","text":""},{"location":"api_conversion.html#jwave.acoustics.conversion.db2neper","title":"<code>db2neper(alpha, y)</code>","text":"<p>Transforms absorption units from decibels to nepers. See http://www.k-wave.org/documentation/db2neper.php</p> <p>Parameters:</p> Name Type Description Default <code>alpha(jnp.ndarray)</code> <p>Absorption coefficient in decibels.</p> required <code>y(jnp.ndarray)</code> <p>Exponent of the absorption coefficient.</p> required <p>Returns:</p> Type Description <p>jnp.ndarray: Absorption coefficient in nepers.</p>"},{"location":"api_extras.html","title":"<code>jwave.extras</code>","text":""},{"location":"api_geometry.html","title":"<code>jwave.geometry</code>","text":""},{"location":"api_geometry.html#jwave.geometry.BLISensors","title":"<code>BLISensors</code>","text":"<p>Band-limited interpolant (off-grid) sensors.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>Tuple of List of float</code> <p>Sensor positions.</p> required <code>n</code> <code>Tuple of int</code> <p>Grid size.</p> required <p>Attributes:</p> Name Type Description <code>positions</code> <code>Tuple[jnp.ndarray]</code> <p>Sensor positions</p> <code>n</code> <code>Tuple[int]</code> <p>Grid size.</p>"},{"location":"api_geometry.html#jwave.geometry.BLISensors.__call__","title":"<code>__call__(p, u, v)</code>","text":"<p>Returns the values of the field p at the sensors positions.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Field</code> <p>The field to be sampled.</p> required"},{"location":"api_geometry.html#jwave.geometry.Medium","title":"<code>Medium</code>","text":"<p>         Bases: <code>Module</code></p> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>eqx</code> <code>_type_</code> <p>description</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> <code>TypeError</code> <p>description</p> <code>ValueError</code> <p>description</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p>"},{"location":"api_geometry.html#jwave.geometry.Medium.int_pml_size","title":"<code>int_pml_size: int</code>  <code>property</code>","text":"<p>Returns the size of the PML layer as an integer</p>"},{"location":"api_geometry.html#jwave.geometry.Medium.max_attenuation","title":"<code>max_attenuation</code>  <code>property</code>","text":"<p>Calculate and return the maximum attenuation.</p> <p>This property uses the <code>attenuation</code> method/function and applies the <code>amax</code> function from JAX's numpy (jnp) library to find the maximum attenuation value.</p> <p>Returns:</p> Type Description <p>The maximum attenuation value.</p>"},{"location":"api_geometry.html#jwave.geometry.Medium.max_density","title":"<code>max_density</code>  <code>property</code>","text":"<p>Calculate and return the maximum density.</p> <p>This property uses the <code>density</code> method/function and applies the <code>amax</code> function from JAX's numpy (jnp) library to find the maximum density value.</p> <p>Returns:</p> Type Description <p>The maximum density value.</p>"},{"location":"api_geometry.html#jwave.geometry.Medium.max_sound_speed","title":"<code>max_sound_speed</code>  <code>property</code>","text":"<p>Calculate and return the maximum sound speed.</p> <p>This property uses the <code>sound_speed</code> method/function and applies the <code>amax</code> function from JAX's numpy (jnp) library to find the maximum sound speed value.</p> <p>Returns:</p> Type Description <p>The maximum sound speed value.</p>"},{"location":"api_geometry.html#jwave.geometry.Medium.min_attenuation","title":"<code>min_attenuation</code>  <code>property</code>","text":"<p>Calculate and return the minimum attenuation.</p> <p>This property uses the <code>attenuation</code> method/function and applies the <code>amin</code> function from JAX's numpy (jnp) library to find the minimum attenuation value.</p> <p>Returns:</p> Type Description <p>The minimum attenuation value.</p>"},{"location":"api_geometry.html#jwave.geometry.Medium.min_density","title":"<code>min_density</code>  <code>property</code>","text":"<p>Calculate and return the minimum density.</p> <p>This property uses the <code>density</code> method/function and applies the <code>amin</code> function from JAX's numpy (jnp) library to find the minimum density value.</p> <p>Returns:</p> Type Description <p>The minimum density value.</p>"},{"location":"api_geometry.html#jwave.geometry.Medium.min_sound_speed","title":"<code>min_sound_speed</code>  <code>property</code>","text":"<p>Calculate and return the minimum sound speed.</p> <p>This property uses the <code>sound_speed</code> method/function and applies the <code>amin</code> function from JAX's numpy (jnp) library to find the minimum sound speed value.</p> <p>Returns:</p> Type Description <p>The minimum sound speed value.</p>"},{"location":"api_geometry.html#jwave.geometry.Medium.__infer_type_parameter__","title":"<code>__infer_type_parameter__(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Inter the type parameter from the arguments. Defaults to FourierSeries if the parameters are all floats</p>"},{"location":"api_geometry.html#jwave.geometry.Medium.__init_type_parameter__","title":"<code>__init_type_parameter__(t)</code>  <code>classmethod</code>","text":"<p>Check whether the type parameters is valid.</p>"},{"location":"api_geometry.html#jwave.geometry.Sensors","title":"<code>Sensors</code>","text":"<p>Sensors structure</p> <p>Attributes:</p> Name Type Description <code>positions</code> <code>Tuple[List[int]]</code> <p>sensors positions</p> <p>Example</p> <pre><code>x_pos = [10,20,30,40]\ny_pos = [30,30,30,30]\nsensors = geometry.Sensors(positions=(x_pos, y_pos))\n</code></pre>"},{"location":"api_geometry.html#jwave.geometry.Sensors.__call__","title":"<code>__call__(p, u, rho)</code>","text":"<p>Returns the values of the field u at the sensors positions.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Field</code> <p>The field to be sampled.</p> required"},{"location":"api_geometry.html#jwave.geometry.Sensors.to_binary_mask","title":"<code>to_binary_mask(N)</code>","text":"<p>Convert sensors to binary mask</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>Tuple[int]</code> <p>grid size</p> required <p>Returns:</p> Type Description <p>jnp.ndarray: binary mask</p>"},{"location":"api_geometry.html#jwave.geometry.Sources","title":"<code>Sources</code>","text":"<p>Sources structure</p> <p>Attributes:</p> Name Type Description <code>positions</code> <code>Tuple[List[int]</code> <p>source positions</p> <code>signals</code> <code>List[jnp.ndarray]</code> <p>source signals</p> <code>dt</code> <code>float</code> <p>time step</p> <code>domain</code> <code>Domain</code> <p>domain</p> <p>Example</p> <pre><code>x_pos = [10,20,30,40]\ny_pos = [30,30,30,30]\nsignal = jnp.sin(jnp.linspace(0,10,100))\nsignals = jnp.stack([signal]*4)\nsources = geometry.Source(positions=(x_pos, y_pos), signals=signals)\n</code></pre>"},{"location":"api_geometry.html#jwave.geometry.Sources.to_binary_mask","title":"<code>to_binary_mask(N)</code>","text":"<p>Convert sources to binary mask</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>Tuple[int]</code> <p>grid size</p> required <p>Returns:</p> Type Description <p>jnp.ndarray: binary mask</p>"},{"location":"api_geometry.html#jwave.geometry.TimeAxis","title":"<code>TimeAxis</code>","text":"<p>Temporal vector to be used for acoustic simulation based on the pseudospectral method of k-Wave</p> <p>Attributes:</p> Name Type Description <code>dt</code> <code>float</code> <p>time step</p> <code>t_end</code> <code>float</code> <p>simulation end time</p>"},{"location":"api_geometry.html#jwave.geometry.TimeAxis.Nt","title":"<code>Nt</code>  <code>property</code>","text":"<p>Returns the number of time steps</p>"},{"location":"api_geometry.html#jwave.geometry.TimeAxis.from_medium","title":"<code>from_medium(medium, cfl=0.3, t_end=None)</code>  <code>staticmethod</code>","text":"<p>Construct a <code>TimeAxis</code> object from <code>kGrid</code> and <code>Medium</code></p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>kGrid</code> required <code>medium</code> <code>Medium</code> required <code>cfl</code> <code>float</code> <p>The CFL number. Defaults to 0.3.</p> <code>0.3</code> <code>t_end</code> <code>[float]</code> <p>The final simulation time. If None,   it is automatically calculated as the time required to travel   from one corner of the domain to the opposite one.</p> <code>None</code>"},{"location":"api_geometry.html#jwave.geometry.TimeAxis.to_array","title":"<code>to_array()</code>","text":"<p>Returns the time-axis as an array</p>"},{"location":"api_geometry.html#jwave.geometry.TimeHarmonicSource","title":"<code>TimeHarmonicSource</code>  <code>dataclass</code>","text":"<p>TimeHarmonicSource dataclass</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>Domain</code> <p>domain</p> <code>amplitude</code> <code>Field</code> <p>The complex amplitude field of the sources</p> <code>omega</code> <code>float</code> <p>The angular frequency of the sources</p>"},{"location":"api_geometry.html#jwave.geometry.TimeHarmonicSource.on_grid","title":"<code>on_grid(t=0.0)</code>","text":"<p>Returns the complex field corresponding to the sources distribution at time $t$.</p>"},{"location":"api_geometry.html#jwave.geometry.bli_function","title":"<code>bli_function(x0, x, n, include_imag=False)</code>","text":"<p>The function used to compute the band limited interpolation function.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>jnp.ndarray</code> <p>Position of the sensors along the axis.</p> required <code>x</code> <code>jnp.ndarray</code> <p>Grid positions.</p> required <code>n</code> <code>int</code> <p>Size of the grid</p> required <code>include_imag</code> <code>bool</code> <p>Include the imaginary component?</p> <code>False</code> <p>Returns:</p> Type Description <code>jnp.ndarray</code> <p>jnp.ndarray: The values of the function at the grid positions.</p>"},{"location":"api_geometry.html#jwave.geometry.circ_mask","title":"<code>circ_mask(N, radius, centre)</code>","text":"<p>Generate a 2D binary mask representing a circle within a 2D grid.</p> <p>The mask is an ndarray of size N with 1s inside the circle (defined by a given centre and radius) and 0s outside.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>Tuple[int, int]</code> <p>The shape of the output mask (size of the grid). It should be in the format (x_size, y_size).</p> required <code>radius</code> <code>float</code> <p>The radius of the circle.</p> required <code>centre</code> <code>Union[List[float], Tuple[float, float]]</code> <p>The coordinates of the centre of the circle in the format (x, y).</p> required <p>Returns:</p> Name Type Description <code>mask</code> <code>np.ndarray</code> <p>The 2D mask as a numpy ndarray of integers. The shape of the mask is N. Values inside the circle are 1, and values outside the circle are 0.</p>"},{"location":"api_geometry.html#jwave.geometry.fibonacci_sphere","title":"<code>fibonacci_sphere(n, radius, centre, cast_int=True)</code>","text":"<p>Generate evenly distributed points on the surface of a sphere using the Fibonacci Sphere method.</p> <p>n (int): The number of points to generate. radius (float): The radius of the sphere. centre (tuple or np.ndarray): The (x, y, z) coordinates of     the center of the sphere. cast_int (bool, optional): If True, points will be rounded     and converted to integers. Default is True.</p> <p>x, y, z (tuple): The x, y, and z coordinates of the points on the sphere.</p>"},{"location":"api_geometry.html#jwave.geometry.get_line_transducer","title":"<code>get_line_transducer(domain, position, width, angle=0)</code>","text":"<p>Construct a line transducer (2D)</p>"},{"location":"api_geometry.html#jwave.geometry.points_on_circle","title":"<code>points_on_circle(n, radius, centre, cast_int=True, angle=0.0, max_angle=2 * np.pi)</code>","text":"<p>Generate points on a circle.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of points.</p> required <code>radius</code> <code>float</code> <p>Radius of the circle.</p> required <code>centre</code> <code>tuple</code> <p>Centre coordinates of the circle (x, y).</p> required <code>cast_int</code> <code>bool</code> <p>If True, points will be rounded and converted to integers. Default is True.</p> <code>True</code> <code>angle</code> <code>float</code> <p>Starting angle in radians. Default is 0.</p> <code>0.0</code> <code>max_angle</code> <code>float</code> <p>Maximum angle to reach in radians. Default is 2*pi (full circle).</p> <code>2 * np.pi</code> <p>Returns:</p> Type Description <code>Tuple[List[float], List[float]]</code> <p>x, y (tuple): Lists of x and y coordinates of the points.</p>"},{"location":"api_geometry.html#jwave.geometry.sphere_mask","title":"<code>sphere_mask(N, radius, centre)</code>","text":"<p>Generate a 3D binary mask representing a sphere within a 3D grid.</p> <p>The mask is an ndarray of size N with 1s inside the sphere (defined by a given centre and radius) and 0s outside.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>Tuple[int, int, int]</code> <p>The shape of the output mask (size of the grid). It should be in the format (x_size, y_size, z_size).</p> required <code>radius</code> <code>float</code> <p>The radius of the sphere.</p> required <code>centre</code> <code>Union[List[float], Tuple[float, float, float]]</code> <p>The coordinates of the centre of the sphere in the format (x, y, z).</p> required <p>Returns:</p> Name Type Description <code>mask</code> <code>np.ndarray</code> <p>The 3D mask as a numpy ndarray of integers. The shape of the mask is N. Values inside the sphere are 1, and values outside the sphere are 0.</p>"},{"location":"api_geometry.html#jwave.geometry.unit_fibonacci_sphere","title":"<code>unit_fibonacci_sphere(samples=128)</code>","text":"<p>Generate evenly distributed points on the surface of a unit sphere using the Fibonacci Sphere method.</p> <p>From https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere</p> <p>Parameters:</p> Name Type Description Default <code>samples</code> <code>int</code> <p>The number of points to generate. Default is 128.</p> <code>128</code> <p>Returns:</p> Name Type Description <code>points</code> <code>list</code> <p>A list of tuples representing the (x, y, z) coordinates of the points on the sphere.</p>"},{"location":"api_operators.html","title":"Macro Rendering Error","text":"<p>File: <code>api_operators.md</code></p> <p>AttributeError: 'MethodList' object has no attribute 'keys'</p> <pre><code>Traceback (most recent call last):\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/mkdocs_macros/plugin.py\", line 644, in render\n    return md_template.render(**page_variables)\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/jinja2/environment.py\", line 1304, in render\n    self.environment.handle_exception()\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/jinja2/environment.py\", line 939, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 16, in top-level template code\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/plumkdocs/main.py\", line 282, in implementations\n    return mod_to_string(module, function)\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/plumkdocs/main.py\", line 253, in mod_to_string\n    implementations = list(map(_extract_implementations, operators))\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/plumkdocs/main.py\", line 207, in _extract_implementations\n    for signature, method in zip(function.methods.keys(), function.methods.values()):\nAttributeError: 'MethodList' object has no attribute 'keys'\n</code></pre>"},{"location":"api_phantoms.html","title":"<code>jwave.phantoms</code>","text":""},{"location":"api_phantoms.html#jwave.phantoms.three_circles","title":"<code>three_circles(N)</code>","text":"<p>Generate a 3-circle phantom.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>tuple</code> <p>The size of the phantom. Must be of length 2.</p> required <p>Returns:</p> Type Description <code>jnp.ndarray</code> <p>jnp.ndarray: The phantom.</p>"},{"location":"api_signal_processing.html","title":"<code>jwave.signal_processing</code>","text":""},{"location":"api_signal_processing.html#jwave.signal_processing.analytic_signal","title":"<code>analytic_signal(x, axis=-1)</code>","text":"<p>Computes the analytic signal from a real signal <code>x</code>, using the FFT.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>jnp.ndarray</code> <p>[description]</p> required <code>axis</code> <code>int</code> <p>[description]. Defaults to -1.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Array</code> <p>jnp.ndarray: [description]</p>"},{"location":"api_signal_processing.html#jwave.signal_processing.apply_ramp","title":"<code>apply_ramp(signal, dt, center_freq, warmup_cycles=3)</code>","text":"<p>Processes the signal $s(t)$ as</p> <p>$$ s(t)\\cdot \\text{min}(1, f_0t/\\sigma) $$</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>jnp.ndarray</code> <p>[description]</p> required <code>dt</code> <code>float</code> <p>[description]</p> required <code>center_freq</code> <code>float</code> <p>$f_0$</p> required <code>warmup_cycles</code> <code>float</code> <p>$\\sigma$. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>Array</code> <p>jnp.ndarray: [description]</p>"},{"location":"api_signal_processing.html#jwave.signal_processing.blackman","title":"<code>blackman(N)</code>","text":"<p>Returns the blackman window of length <code>N</code></p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>[description]</p> required <p>Returns:</p> Type Description <code>Array</code>"},{"location":"api_signal_processing.html#jwave.signal_processing.fourier_downsample","title":"<code>fourier_downsample(x, subsample=2, discard_last=True)</code>","text":"<p>Downsample a signal by taking the Fourier transform and discarding the high frequencies.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>jnp.ndarray</code> <p>Signal to be downsampled</p> required <code>subsample</code> <code>int</code> <p>Sumsampling factor. Defaults to 2.</p> <code>2</code> <code>discard_last</code> <code>bool</code> <p>If True, the last dimension is not subsampled. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Array</code> <p>jnp.ndarray: [description]</p>"},{"location":"api_signal_processing.html#jwave.signal_processing.fourier_upsample","title":"<code>fourier_upsample(x, upsample=2, discard_last=True)</code>","text":"<p>Upsample a signal by taking the Fourier transform and adding zeros at the high frequencies.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>jnp.ndarray</code> <p>Signal to be upsampled</p> required <code>upsample</code> <code>int</code> <p>Upsampling factor. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>Array</code> <p>jnp.ndarray: Upsampled signal</p>"},{"location":"api_signal_processing.html#jwave.signal_processing.gaussian_window","title":"<code>gaussian_window(signal, time, mu, sigma)</code>","text":"<p>Returns the gaussian window</p> <p>$$ s(t)\\cdot \\exp \\left( - \\frac{(t-\\mu)^2}{\\sigma^2} \\right) $$</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>jnp.ndarray</code> <p>$s(t)$</p> required <code>time</code> <code>jnp.ndarray</code> <p>$t$</p> required <code>mu</code> <code>float</code> <p>$\\mu$</p> required <code>sigma</code> <code>float</code> <p>$\\sigma$</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jnp.ndarray: [description]</p>"},{"location":"api_signal_processing.html#jwave.signal_processing.smooth","title":"<code>smooth(x, exponent=1.0)</code>","text":"<p>Smooths a  n-dimensioanl signal by multiplying its spectrum by a blackman window.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>jnp.ndarray</code> <p>[description]</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jnp.ndarray: [description]</p>"},{"location":"api_signal_processing.html#jwave.signal_processing.smoothing_filter","title":"<code>smoothing_filter(sample_input)</code>","text":"<p>Returns a smoothing filter based on the blackman window, which works on a signal similar to the one provided as input. The filter is amenable to jax transformations.</p> <p>Parameters:</p> Name Type Description Default <code>sample_input</code> <code>jnp.ndarray</code> <p>Example signal</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Smoothing filter</p>"},{"location":"api_signal_processing.html#jwave.signal_processing.tone_burst","title":"<code>tone_burst(sample_freq, signal_freq, num_cycles)</code>","text":"<p>Returns a tone burst</p> <p>Parameters:</p> Name Type Description Default <code>sample_freq</code> <code>float</code> <p>Sampling frequency</p> required <code>signal_freq</code> <code>float</code> <p>Signal frequency</p> required <code>num_cycles</code> <code>float</code> <p>Number of cycles</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jnp.ndarray: The tone burst signal</p>"},{"location":"api_time_harmonic.html","title":"Macro Rendering Error","text":"<p>File: <code>api_time_harmonic.md</code></p> <p>AttributeError: 'MethodList' object has no attribute 'keys'</p> <pre><code>Traceback (most recent call last):\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/mkdocs_macros/plugin.py\", line 644, in render\n    return md_template.render(**page_variables)\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/jinja2/environment.py\", line 1304, in render\n    self.environment.handle_exception()\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/jinja2/environment.py\", line 939, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 11, in top-level template code\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/plumkdocs/main.py\", line 282, in implementations\n    return mod_to_string(module, function)\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/plumkdocs/main.py\", line 253, in mod_to_string\n    implementations = list(map(_extract_implementations, operators))\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/plumkdocs/main.py\", line 207, in _extract_implementations\n    for signature, method in zip(function.methods.keys(), function.methods.values()):\nAttributeError: 'MethodList' object has no attribute 'keys'\n</code></pre>"},{"location":"api_time_varying.html","title":"Macro Rendering Error","text":"<p>File: <code>api_time_varying.md</code></p> <p>AttributeError: 'MethodList' object has no attribute 'keys'</p> <pre><code>Traceback (most recent call last):\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/mkdocs_macros/plugin.py\", line 644, in render\n    return md_template.render(**page_variables)\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/jinja2/environment.py\", line 1304, in render\n    self.environment.handle_exception()\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/jinja2/environment.py\", line 939, in handle_exception\n    raise rewrite_traceback_stack(source=source)\n  File \"&lt;template&gt;\", line 13, in top-level template code\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/plumkdocs/main.py\", line 282, in implementations\n    return mod_to_string(module, function)\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/plumkdocs/main.py\", line 253, in mod_to_string\n    implementations = list(map(_extract_implementations, operators))\n  File \"/home/runner/.cache/pypoetry/virtualenvs/jwave-gL0cM221-py3.10/lib/python3.10/site-packages/plumkdocs/main.py\", line 207, in _extract_implementations\n    for signature, method in zip(function.methods.keys(), function.methods.values()):\nAttributeError: 'MethodList' object has no attribute 'keys'\n</code></pre>"},{"location":"api_utils.html","title":"<code>jwave.utils</code>","text":""},{"location":"api_utils.html#jwave.utils.display_complex_field","title":"<code>display_complex_field(field, figsize=(15, 8), max_intensity=None)</code>","text":"<p>Displays the real and absolute value of a complex field.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>Union[Field, jnp.ndarray, np.ndarray]</code> <p>Complex field to plot.</p> required <code>figsize</code> <code>Tuple[int, int]</code> <p>Figure size.</p> <code>(15, 8)</code> <code>max_intensity</code> <code>Union[float, None]</code> <p>Maximum intensity to plot. If None, the maximum intensity is set to the maximum absolute value of the field. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Figure, np.ndarray]</code> <p>Tuple[matplotlib.pyplot.figure, matplotlib.pyplot.axes]: Tuple of Figure object and Axes object.</p>"},{"location":"api_utils.html#jwave.utils.get_smallest_prime_factors","title":"<code>get_smallest_prime_factors(n)</code>","text":"<p>Get the smallest prime factors of a given number.</p> <p>Args      n (int): The number to find the smallest prime factors for.</p> <p>Returns:      Set[int]: A set containing the smallest prime factors of the number.</p>"},{"location":"api_utils.html#jwave.utils.is_numeric","title":"<code>is_numeric(x)</code>","text":"<p>Check if x is a numeric value, including complex.</p>"},{"location":"api_utils.html#jwave.utils.load_image_to_numpy","title":"<code>load_image_to_numpy(filepath, padding=0, image_size=None)</code>","text":"<p>Loads an image from a filepath and returns it as a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Filepath to the image.</p> required <code>padding</code> <code>int</code> <p>Padding to add to the image. Defaults to 0.</p> <code>0</code> <code>image_size</code> <code>Tuple[int, int]</code> <p>Size of the image (excluding padding). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>np.ndarray: Image as a numpy array.</p>"},{"location":"api_utils.html#jwave.utils.numbers_with_smallest_primes","title":"<code>numbers_with_smallest_primes(min_range, max_range, max_prime=7)</code>","text":"<p>Print the numbers within a given range that have smallest prime factors all less than or equal to a maximum value.</p> <p>Parameters:</p> Name Type Description Default <code>min_range</code> <code>int</code> <p>The minimum value of the range to search within.</p> required <code>max_range</code> <code>int</code> <p>The maximum value of the range to search within.</p> required <code>max_prime</code> <code>int</code> <p>The maximum prime factor that numbers in the range can have. Default is 7.</p> <code>7</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This function prints the qualifying numbers and their smallest prime factors.</p>"},{"location":"api_utils.html#jwave.utils.plot_comparison","title":"<code>plot_comparison(field1, field2, title='', names=('', ''), cmap='seismic', vmin=None, vmax=None)</code>","text":"<p>Plots two 2D fields side by side, and shows the difference between them.</p> <p>Parameters:</p> Name Type Description Default <code>field1</code> <code>jnp.ndarray</code> <p>First field</p> required <code>field2</code> <code>jnp.ndarray</code> <p>Second Field</p> required <code>title</code> <code>str</code> <p>Title of the plot. Defaults to ''.</p> <code>''</code> <code>names</code> <code>Iterable[str]</code> <p>Names of the fields . Defaults to <code>('','')</code>.</p> <code>('', '')</code> <code>cmap</code> <code>str</code> <p>Colormap to use. Defaults to 'seismic'.</p> <code>'seismic'</code> <code>vmin</code> <code>float</code> <p>Minimum value to use for the colormap. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Maximum value to use for the colormap. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Figure</code> <code>Figure</code> <p>Figure object.</p>"},{"location":"api_utils.html#jwave.utils.show_field","title":"<code>show_field(x, title='', figsize=(8, 6), vmax=None, aspect='auto')</code>","text":"<p>Plots a real valued field. The colormap goes from <code>-vmax</code> to <code>vmax</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Field</code> <p>Field to plot.</p> required <code>title</code> <code>str</code> <p>Title of the plot. Defaults to \"\".</p> <code>''</code> <code>figsize</code> <code>tuple</code> <p>Figure size. Defaults to (8,6).</p> <code>(8, 6)</code> <code>vmax</code> <code>float</code> <p>Maximum value to display. Defaults to None.</p> <code>None</code> <code>aspect</code> <code>str</code> <p>Aspect ratio of the plot. Defaults to \"auto\".</p> <code>'auto'</code> <p>Returns:</p> Type Description <p>matplotlib.pyplot.figure: Figure object.</p> <p>matplotlib.pyplot.axes: Axes object.</p>"},{"location":"benchmarks.html","title":"Benchmarks","text":"<p>Some of the benchmarks required the <code>extras</code> module to be correctly setup.</p>"},{"location":"changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog.html#unreleased","title":"Unreleased","text":""},{"location":"changelog.html#021-2024-09-17","title":"0.2.1 - 2024-09-17","text":""},{"location":"changelog.html#changed","title":"Changed","text":"<ul> <li>Upgraded <code>jaxdf</code> dependency</li> </ul>"},{"location":"changelog.html#020-2023-12-18","title":"0.2.0 - 2023-12-18","text":""},{"location":"changelog.html#fixed","title":"Fixed","text":"<ul> <li>Fixed arguments error in helmholtz notebook</li> </ul>"},{"location":"changelog.html#changed_1","title":"Changed","text":"<ul> <li><code>Medium</code> objects are now <code>jaxdf.Module</code>s, which is based on <code>equinox</code> modules. It is also a parametric module for dispatching operators, meaning that there's a type difference betwee <code>Medium[FourierSeries]</code> and <code>Medium[FiniteDifferences]</code>, for example.</li> <li>The settings of time domain acoustic simulations are now set using a <code>TimeWavePropagationSettings</code>. This also includes an attribute to explicity set the reference sound speed.</li> </ul>"},{"location":"changelog.html#added","title":"Added","text":"<ul> <li>Added a logger in <code>jwave.logger</code></li> </ul>"},{"location":"changelog.html#removed","title":"Removed","text":"<ul> <li>Removed <code>pressure_from_density</code> from <code>jwave.acoustics.conversion</code>, as it was a duplicate</li> </ul>"},{"location":"changelog.html#015-2023-09-27","title":"0.1.5 - 2023-09-27","text":""},{"location":"changelog.html#added_1","title":"Added","text":"<ul> <li>Added <code>numbers_with_smallest_primes</code> utility to find grids with small primes for efficient FFT when using FourierSeries</li> </ul>"},{"location":"changelog.html#fixed_1","title":"Fixed","text":"<ul> <li>Restored <code>default_params</code> for the helmholtz operators that wen missing since the last jaxdf update</li> </ul>"},{"location":"changelog.html#014-2023-06-29","title":"0.1.4 - 2023-06-29","text":""},{"location":"changelog.html#changed_2","title":"Changed","text":"<ul> <li>Refactored <code>save_video</code> to use opencv.</li> </ul>"},{"location":"changelog.html#deprecated","title":"Deprecated","text":"<ul> <li><code>plot_complex_field</code> has been deprecated in favor of <code>display_complex_field</code></li> </ul>"},{"location":"changelog.html#removed_1","title":"Removed","text":"<ul> <li>Removed the uncertainty propagation notebook example. For a more in depth example of using linear uncertainty propagation see this repository</li> </ul>"},{"location":"changelog.html#added_2","title":"Added","text":"<ul> <li>Exposed <code>points_on_circle</code> function to generate points on a circle</li> <li>Exposed <code>unit_fibonacci_sphere</code> function</li> <li>Exposed <code>fibonacci_sphere</code> function</li> <li>Exposed <code>sphere_mask</code> function for creating spherical binary masks</li> <li>Exposed <code>circ_mask</code> function for creating circular binary masks</li> <li>Exposed bli_function that is used to compute the band limited interpolant</li> </ul>"},{"location":"changelog.html#013-2023-06-28","title":"0.1.3 - 2023-06-28","text":""},{"location":"changelog.html#added_3","title":"Added","text":"<ul> <li>Added off grid sensors [@tomelse]</li> </ul>"},{"location":"changelog.html#012-2023-06-22","title":"0.1.2 - 2023-06-22","text":""},{"location":"changelog.html#changed_3","title":"Changed","text":"<ul> <li>updated documentation</li> <li>made imageio and tqdm optional dependencies</li> </ul>"},{"location":"changelog.html#011-2023-06-22","title":"0.1.1 - 2023-06-22","text":""},{"location":"changelog.html#fixed_2","title":"Fixed","text":"<ul> <li>fixed pypi classifiers</li> </ul>"},{"location":"changelog.html#010-2023-06-22","title":"0.1.0 - 2023-06-22","text":""},{"location":"changelog.html#added_4","title":"Added","text":"<ul> <li><code>k0</code> is automatically calculated in the Convergent Born Series, if not given, using the fromula from Osnabrugge et al.</li> </ul>"},{"location":"changelog.html#fixed_3","title":"Fixed","text":"<ul> <li>updated for new <code>Array</code> type in <code>jax</code> 0.4.x</li> </ul>"},{"location":"changelog.html#changed_4","title":"Changed","text":"<ul> <li>reverted checkpoint to only step checkpoints for time varying simulations. Soon jwave will use diffrax for advanced checkpointing</li> </ul>"},{"location":"changelog.html#004-2022-11-04","title":"0.0.4 - 2022-11-04","text":""},{"location":"changelog.html#added_5","title":"Added","text":"<ul> <li>Convergent Born series.</li> </ul>"},{"location":"changelog.html#fixed_4","title":"Fixed","text":"<ul> <li>Correctly handles Nyquist frequency for Helmholtz operator, to improve agreement with k-Wave.</li> <li>Fixed incorrect domain size for angular spectrum.</li> <li>Angular spectrum is only dispatched on <code>pressure</code> types.</li> </ul>"},{"location":"changelog.html#003-2022-07-05","title":"0.0.3 - 2022-07-05","text":""},{"location":"changelog.html#added_6","title":"Added","text":"<ul> <li>Angular spectrum method for single frequency sources.</li> <li>Differentiable rayleigh integral (from a plane)</li> </ul>"},{"location":"changelog.html#002-2022-06-23","title":"0.0.2 - 2022-06-23","text":""},{"location":"changelog.html#added_7","title":"Added","text":"<ul> <li>Generate <code>TimeHarmonicSource</code> from point sources.</li> </ul>"},{"location":"changelog.html#fixed_5","title":"Fixed","text":"<ul> <li>Helmholtz notebook parameters bug.</li> </ul>"},{"location":"changelog.html#001-2022-06-07","title":"0.0.1 - 2022-06-07","text":""},{"location":"changelog.html#added_8","title":"Added","text":"<ul> <li>Finite differences helmholtz tested.</li> <li>Extract time varying params without running the simulation.</li> <li>Windows one-line installer</li> </ul>"},{"location":"changelog.html#fixed_6","title":"Fixed","text":"<ul> <li>Using numpy operations in TimeAxis for static fields.</li> <li>Pml for 1D and 3D simulations.</li> <li>Plotting functions of <code>jwave.utils</code> now work with both <code>Field</code>s and arrays.</li> </ul>"},{"location":"contributing.html","title":"Contributing","text":"<p>Contributions in the form of pull requests are very welcome! Here's how to get started.</p> <p></p>"},{"location":"contributing.html#getting-started","title":"Getting started","text":"<p>First, fork the library on GitHub. You can do this by clicking on the <code>Fork</code> button in the GitHub interface.</p> <p>Next, clone and install the library in development mode:</p> <pre><code>git clone git@github.com:YOUR_GIT_USERNAME/jwave.git\ncd jwave\npip install poetry\npoetry install\n</code></pre> <p>After that, install the pre-commit hooks:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre> <p></p>"},{"location":"contributing.html#if-youre-making-changes-to-the-code","title":"If you're making changes to the code","text":"<p>Run <code>git checkout -b my_contribution</code> and make your changes. Be sure to include additional tests if necessary. Increasing the coverage in the coverage report would be great! \ud83d\ude03</p> <p>After making your changes, verify that all tests pass.</p> <pre><code>coverage run --source=jwave -m pytest -xvs\n</code></pre> <p>Since regression tests can take a long time to run, it's possible to initially only run unit and integration tests, using:</p> <pre><code>coverage run --source=jwave -m pytest -xvs --ignore=tests/regression_tests\n</code></pre> <p>Once you are satisfied with your changes, add an entry to the changelog using kacl-cli, for example:</p> <pre><code>kacl-cli add fixed \"Fixed the unfixable issue \ud83c\udf89\" --modify\n</code></pre> <p>For more information on the types of changes that can be added to the changelog, visit this page.</p> <p>Then commit and push your changes back to your fork of the repository:</p> <pre><code>git push\n</code></pre> <p>Finally, open a pull request on GitHub! You can do this by clicking on the Pull Request button in the GitHub interface.</p> <p>Wait for the CI to run, and one of the developers will review your PR.</p> <p></p>"},{"location":"contributing.html#if-youre-making-changes-to-the-documentation","title":"If you're making changes to the documentation","text":"<p>Make your changes, and then build the documentation using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Please note that due to the way <code>operator</code>s are documented, this might take some time.</p> <p>You can view your local copy of the documentation by navigating to <code>localhost:8000</code> in a web browser.</p>"},{"location":"macros.html","title":"Macros","text":"In\u00a0[\u00a0]: Copied! <pre>from plumkdocs import define_env\n</pre> from plumkdocs import define_env In\u00a0[\u00a0]: Copied! <pre>__all__ = ['define_env']\n</pre> __all__ = ['define_env']"},{"location":"install/on_linux.html","title":"Install on Linux / OSx","text":""},{"location":"install/on_linux.html#install-in-an-existing-environment","title":"Install in an existing environment","text":"<p>Follow the instructions to install Jax with CUDA support if you want to use your GPU.</p> <p>Then, simply install <code>jwave</code> using pip</p> <pre><code>pip install jwave\n</code></pre>"},{"location":"install/on_linux.html#install-automatically-in-a-new-environment","title":"Install automatically in a new environment","text":"<p>You can use the provided make file to generate an existing environment that contains <code>jwave</code>.</p> <p>First, clone the repository and move into its root directory</p> <pre><code>git clone git@github.com:ucl-bug/jwave.git\ncd jwave\n</code></pre> <p>Then, generate the environment using</p> <pre><code>make virtualenv\n</code></pre> <p>Install jax with GPU support (assumes CUDA &gt; 11.1) using</p> <pre><code>make jaxgpu\n</code></pre> <p>Before using <code>jwave</code>,  activate the environment from the root folder of jwave using</p> <pre><code>source .venv/bin/activate\n</code></pre>"},{"location":"install/on_win.html","title":"Install on Windows","text":"<p><code>jwave</code> is based on JAX, which currently offers limited support for Windows platforms (see this issue for more information).</p> <p>Following are a few workarounds for running <code>jax</code> (and, therefore, <code>jwave</code>) on a Windows machine:</p> <ol> <li>Install on an isolated WSL</li> <li>Install using the unofficial jax wheels</li> <li>Building jax from source</li> </ol> <p>Before running any of them, please make sure that your Windows machine is up-to-date, by clicking on <code>Start</code>, then typing <code>Check for updates</code> in the search bar and pressing enter. Install any updates that are available.</p> <p>Any help to improve the installation on Windows is more than welcome \ud83d\ude0a.</p> <p></p>"},{"location":"install/on_win.html#install-on-an-isolated-wsl","title":"Install on an isolated WSL","text":"<p>This is the easiest option. It uses the Windows Subsystem for Linux (WSL) to install an Arch-based Linux distribution, in which python and the required packages are installed.</p> <p>The WSL and other required programs are installed using <code>scoop</code> without Adiministrator privileges, which ensures that they are isolated from the rest of the system and minimizes the risk of interference with other programs.</p> <p>The WSL shares the same filesystem as the host machine, therefore all files can be accessed directly from the Windows File Explorer. For developing your Python code, we recommend to use Visual Studio Code with the Remote - WSL extension: see this page for a detailed tutorial.</p>"},{"location":"install/on_win.html#prerequisites","title":"Prerequisites","text":"<p>You must be running Windows 10 version 2004 and higher (Build 19041 and higher) or Windows 11.</p> <p>Make sure that the Windows Subsystem for Linux feature is enabled in your system. Click on <code>Start</code>, type <code>PowerShell</code>, then right-click on <code>Windows PowerShell</code> and click <code>Run As Administrator</code>.</p> <p>In the PowerShell window, type the following command and press <code>Enter</code>:</p> <pre><code>dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n</code></pre> <p>Similarly, check that the Virtual Machine feature is enabled by typing the following command and pressing <code>Enter</code>:</p> <pre><code>dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n</code></pre> <p>Close the PowerShell window and restart your computer.</p> <p>The next step is to make sure that your system has the latest Linux kernel update, by downloading and installing this package.</p>"},{"location":"install/on_win.html#how-to-install","title":"How to install","text":"<p>Open a <code>PowerShell</code> instance and paste this</p> <pre><code>$JwaveWinInstaller = Invoke-WebRequest https://raw.githubusercontent.com/ucl-bug/jwave/main/scripts/jwave_win_install.ps1\nInvoke-Expression $($JwaveWinInstaller.Content)\n</code></pre> <p>then follow the instructions to install <code>jwave</code>.</p>"},{"location":"install/on_win.html#how-to-uninstall","title":"How to uninstall","text":"<p>If you have installed <code>jwave</code> using the script above, open a <code>PowerShell</code> instance and type</p> <pre><code>scoop uninstall scoop\n</code></pre> <p>to completely remove jwave and all other programs installed (e.g. the virtual machine).</p> <p></p>"},{"location":"install/on_win.html#install-using-the-unofficial-jax-wheels","title":"Install using the unofficial jax wheels","text":"<p>\u26a0\ufe0f This method uses a community supported Windows build for jax, which is in alpha state and is not guaranteed to work. Only CPU and CUDA 11.x are supported.</p>"},{"location":"install/on_win.html#prerequisites_1","title":"Prerequisites","text":"<p>This method assumes that you've aready setup a Python environment in your Windows machine. We recommend to use Anaconda to keep your Python installation separate from the rest of your system: this page offers a relatively quick guide to Anaconda installation and how to manage environments.</p>"},{"location":"install/on_win.html#how-to-install_1","title":"How to install","text":"<p>After activating your python environment, follow the README to install <code>jax</code> for your python and (if needed) CUDA version.</p> <p>Then install <code>jwave</code> using</p> <pre><code>pip install git+https://github.com/ucl-bug/jwave`\n</code></pre> <p></p>"},{"location":"install/on_win.html#building-jax-from-source","title":"Building jax from source","text":"<p>The latest method is to build <code>jax</code> from source. This is not recommended for users that are not familiar with building large software packages from source.</p>"},{"location":"install/on_win.html#how-to-install_2","title":"How to install","text":"<p>Follow the guide on the jax docs for building <code>jax</code> from source, up to the end of the \"Running the tests\" section</p> <p>Then install <code>jwave</code> using</p> <pre><code>pip install git+https://github.com/ucl-bug/jwave\n</code></pre>"},{"location":"notebooks/prerequisites.html","title":"Prerequisites","text":"In\u00a0[\u00a0]: Copied! <pre>from jax import numpy as jnp\n\ndef f(x, y, a=1.,b=1.):\n    return a*(x**2) + b*y\n\n#\u00a0Testing function\nx = 2.\ny = 3.\n\nz = f(x, y, 3.,2.)\n\nprint(f\"(x,y) = {[x,y]}\\tf(x,y) = {z}\")\n</pre> from jax import numpy as jnp  def f(x, y, a=1.,b=1.):     return a*(x**2) + b*y  #\u00a0Testing function x = 2. y = 3.  z = f(x, y, 3.,2.)  print(f\"(x,y) = {[x,y]}\\tf(x,y) = {z}\") <pre>(x,y) = [2.0, 3.0]\tf(x,y) = 18.0\n</pre> <p>However, some operations, like in-place updates of arrays, are not permitted. For more details on this, see the Sharp Bits section of the <code>jax</code> documentation.</p> In\u00a0[\u00a0]: Copied! <pre>def swap_coordinates(f):\n    def g(x, y, *args, **kwargs): \n        return f(y, x, *args, **kwargs)\n    return g\n    \n# Gets the new function\nf_swapped = swap_coordinates(f)\n\n# Evaluates the new function\nw = f_swapped(x, y, 3., 2.)\n\nprint(f\"(x,y) = {[x,y]}\\t         f(x,y) = {z}\")\nprint(f\"(x,y) = {[x,y]}\\tg(x,y) = f(y,x) = {w}\")\n</pre> def swap_coordinates(f):     def g(x, y, *args, **kwargs):          return f(y, x, *args, **kwargs)     return g      # Gets the new function f_swapped = swap_coordinates(f)  # Evaluates the new function w = f_swapped(x, y, 3., 2.)  print(f\"(x,y) = {[x,y]}\\t         f(x,y) = {z}\") print(f\"(x,y) = {[x,y]}\\tg(x,y) = f(y,x) = {w}\") <pre>(x,y) = [2.0, 3.0]\t         f(x,y) = 18.0\n(x,y) = [2.0, 3.0]\tg(x,y) = f(y,x) = 31.0\n</pre> <p><code>jax</code> comes equipped with many transformations that are useful for machine learning research. One of those transformations is <code>jax.grad</code>, which applies the gradient operator to a function with a scalar output.</p> In\u00a0[\u00a0]: Copied! <pre>import jax\n\n# Gets the gradient function\ngrad_f = jax.grad(f, argnums=(0,1))\n\n# Evaluates the new function\nx = 2.\ny = 4.\nz = f(x, y, 3., 2.)\nx_prime, y_prime = grad_f(x, y, 3., 2.)\n\nprint(f\"(x,y) = {[x,y]}\\tf(x,y) = {z}   \\tf'(x,y) = {[str(x_prime), str(y_prime)]}\")\n</pre> import jax  # Gets the gradient function grad_f = jax.grad(f, argnums=(0,1))  # Evaluates the new function x = 2. y = 4. z = f(x, y, 3., 2.) x_prime, y_prime = grad_f(x, y, 3., 2.)  print(f\"(x,y) = {[x,y]}\\tf(x,y) = {z}   \\tf'(x,y) = {[str(x_prime), str(y_prime)]}\") <pre>WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> <pre>(x,y) = [2.0, 4.0]\tf(x,y) = 20.0   \tf'(x,y) = ['12.0', '2.0']\n</pre> <p>Another important function transformation is <code>jax.jit</code>, which returns a version of the function optimized and compiled for the user hardware</p> In\u00a0[\u00a0]: Copied! <pre>def complex_fun(x):\n    y = jnp.sqrt((x+1)**2)\n    z = jnp.sin(x*3 + x**2 + 1)\n    return jnp.sum(z*y + y)\n\n# Gets the compiled function\nf_jit = jax.jit(complex_fun)\n\n# Evaluates the new function\nx = jnp.ones((10000,10000));\nz = complex_fun(x)\nz_jit = f_jit(x) #\u00a0The function is compiled at its first call\n</pre> def complex_fun(x):     y = jnp.sqrt((x+1)**2)     z = jnp.sin(x*3 + x**2 + 1)     return jnp.sum(z*y + y)  # Gets the compiled function f_jit = jax.jit(complex_fun)  # Evaluates the new function x = jnp.ones((10000,10000)); z = complex_fun(x) z_jit = f_jit(x) #\u00a0The function is compiled at its first call In\u00a0[\u00a0]: Copied! <pre>%timeit complex_fun(x)\n</pre> %timeit complex_fun(x) <pre>793 ms \u00b1 818 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> In\u00a0[\u00a0]: Copied! <pre>%timeit f_jit(x).block_until_ready()\n</pre> %timeit f_jit(x).block_until_ready() <pre>242 ms \u00b1 887 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> In\u00a0[\u00a0]: Copied! <pre>from jwave.geometry import Domain\n\ndomain = Domain(N=(65,65), dx=(1., 1.))\nprint(domain)\n</pre> from jwave.geometry import Domain  domain = Domain(N=(65,65), dx=(1., 1.)) print(domain) <pre>Domain(N=(65, 65), dx=(1.0, 1.0))\n</pre> <p>Other objects are defined as <code>Field</code> subclasses from <code>jaxdf</code>. A <code>Field</code>, in a nutshell, consists of parameters and a representation (or discretization), associated with a domain. For example, the following defines a truncated Fourier Series, for which the value in $(0,0)$ is 1.</p> In\u00a0[\u00a0]: Copied! <pre>from jwave.geometry import FourierSeries\n\nparams = jnp.zeros(domain.N)\nparams = params.at[32,32].set(1.0)\nu = FourierSeries(params, domain)\n</pre> from jwave.geometry import FourierSeries  params = jnp.zeros(domain.N) params = params.at[32,32].set(1.0) u = FourierSeries(params, domain) <p>We can visualize this field on the grid</p> In\u00a0[\u00a0]: Copied! <pre>from jwave.utils import show_field\n\nshow_field(u)\n</pre> from jwave.utils import show_field  show_field(u) <p>Or query the field at a specific point in space</p> In\u00a0[\u00a0]: Copied! <pre>x = jnp.asarray([0., 0.])\nprint(u(x))\n</pre> x = jnp.asarray([0., 0.]) print(u(x)) <pre>[1.]\n</pre> <p>We can also use the latter callable to visualize the underlying discretization, i.e. the bandlimited interpolant, by querying the field at values outside the grid nodes. Here we are usign the vmap function transformation, to efficiently query the field at multiple points.</p> In\u00a0[\u00a0]: Copied! <pre>field_on_plane = jax.vmap(jax.vmap(u))\n\nx = jnp.linspace(-2, 5, 100)\nX, Y = jnp.meshgrid(x,x)\ncoords = jnp.stack([X,Y], -1)\nz = field_on_plane(coords).real[...,0]\n\nshow_field(z)\n</pre> field_on_plane = jax.vmap(jax.vmap(u))  x = jnp.linspace(-2, 5, 100) X, Y = jnp.meshgrid(x,x) coords = jnp.stack([X,Y], -1) z = field_on_plane(coords).real[...,0]  show_field(z) <p>Lastly, there are operators that can be applied to <code>Field</code> objects. Operators are objects that represent some mathematical operator on functions, such as the gradient or the Helmholtz equation, whose numerical implementation depends on the input discretization. They return functions and they can be used inside a function to be transformed using <code>jax</code>.</p> In\u00a0[\u00a0]: Copied! <pre>from jaxdf.operators import laplacian\n\nparams = jnp.zeros(domain.N)\nparams = params.at[32:46,25:58].set(1.0)\nu = FourierSeries(params, domain)\n\nshow_field(u)\n</pre> from jaxdf.operators import laplacian  params = jnp.zeros(domain.N) params = params.at[32:46,25:58].set(1.0) u = FourierSeries(params, domain)  show_field(u) In\u00a0[\u00a0]: Copied! <pre>v = laplacian(u)\nshow_field(v)\n</pre> v = laplacian(u) show_field(v) In\u00a0[15]: Copied! <pre># It is still a Field, so it can be visualized it at higher resolutions \n# using the same method as before\nfield_on_plane = jax.vmap(jax.vmap(v))\n\nx = jnp.linspace(-32, 32, 200)\nX, Y = jnp.meshgrid(x,x)\ncoords = jnp.stack([X,Y], -1)\nz = field_on_plane(coords).real[...,0]\nz = jnp.fliplr(jnp.fliplr(z).T)\n\nshow_field(z)\n</pre> # It is still a Field, so it can be visualized it at higher resolutions  # using the same method as before field_on_plane = jax.vmap(jax.vmap(v))  x = jnp.linspace(-32, 32, 200) X, Y = jnp.meshgrid(x,x) coords = jnp.stack([X,Y], -1) z = field_on_plane(coords).real[...,0] z = jnp.fliplr(jnp.fliplr(z).T)  show_field(z)"},{"location":"notebooks/prerequisites.html#prerequisites","title":"Prerequisites\u00b6","text":"<p>For using <code>jwave</code>, you need to be familiar with <code>jax</code> and the package <code>jaxdf</code>. This page provides a quick introduction to allow you to get started with running simulations.</p>"},{"location":"notebooks/prerequisites.html#jax","title":"JAX\u00b6","text":"<p>jax is a Python library for machine learning and scientific computing, on which <code>jwave</code> is based. To learn how to use <code>jax</code>, please refer to this guide. For our purposes, the two main features of <code>jax</code> that one needs to keep in mind for using <code>jwave</code>:</p>"},{"location":"notebooks/prerequisites.html#1-jax-is-a-drop-in-replacement-for-numpy","title":"1. <code>jax</code> is a drop-in replacement for <code>numpy</code>\u00b6","text":"<p>Writing functions that operate on arrays in <code>jax</code> is extremely similar to doing it in NumPy. For example, we can write a function that calculates a polynomial function of the input and apply it to an array</p>"},{"location":"notebooks/prerequisites.html#2-jax-power-comes-from-function-transformations","title":"2. <code>jax</code> power comes from function transformations.\u00b6","text":"<p>One of the main features of <code>jax</code> is function transformations. It is a concept that may be unfamiliar, especially for users coming from MATLAB (a related concept is function handles).</p> <p>The fundamental idea is to have special functions (from now on called function transformations or high-order functions) that take a function as input and return a function ad output. They are also related to the concept of python decorator.</p> <p>To make things concrete, an example of function transformation (say $\\mathcal{T}$) is one that transform a generic $f(x,y)$ by swapping the $x$ and $y$, yelding the new function $T(f)(x,y) = g(x,y) = f(y,x)$.</p>"},{"location":"notebooks/prerequisites.html#fields","title":"Fields\u00b6","text":"<p>Objects are variables that contain the numerical data used during the simulations. They are often defined as classes registered to the JAX compiler as a custom PyTree node, meaning that they can be passed to functions in the same way as <code>jax.numpy</code> arrays, and they can be initialized within a function.</p> <p>One example is the <code>Domain</code> class from <code>jwave.geometry</code>, which defines the domain where the simulation takes place.</p>"},{"location":"notebooks/prerequisites.html#running-a-simulation","title":"Running a simulation\u00b6","text":"<p>Knowing how to use <code>jax</code> and the <code>jaxdf</code> objects from <code>jaxdf</code>, you can run your first simulation by following the next tutorial.</p>"},{"location":"notebooks/harmonic/helmholtz_problem.html","title":"Helmholtz problem","text":"In\u00a0[1]: Copied! <pre>from functools import partial\n\nimport numpy as np\nfrom jax import jit\nfrom jax import numpy as jnp\nfrom jax import random\nfrom matplotlib import pyplot as plt\n\nfrom jwave import FiniteDifferences, FourierSeries\nfrom jwave.geometry import Domain, Medium, circ_mask\nfrom jwave.utils import display_complex_field, show_positive_field\n\nkey = random.PRNGKey(42)  # Random seed\n</pre> from functools import partial  import numpy as np from jax import jit from jax import numpy as jnp from jax import random from matplotlib import pyplot as plt  from jwave import FiniteDifferences, FourierSeries from jwave.geometry import Domain, Medium, circ_mask from jwave.utils import display_complex_field, show_positive_field  key = random.PRNGKey(42)  # Random seed In\u00a0[2]: Copied! <pre># Defining geometry\nN = (128, 256)  # Grid size\ndx = (0.001, 0.001)  # Spatial resolution\nomega = 1.5e6  # Wavefield omega = 2*pi*f\ntarget = [160, 360]  # Target location\n\n# Defining the domain\ndomain = Domain(N, dx)\n</pre> # Defining geometry N = (128, 256)  # Grid size dx = (0.001, 0.001)  # Spatial resolution omega = 1.5e6  # Wavefield omega = 2*pi*f target = [160, 360]  # Target location  # Defining the domain domain = Domain(N, dx) <p>Performing time-harmonic simulations is very similar to standard wave propagation, with the difference that the source field is a static complex field.</p> In\u00a0[3]: Copied! <pre># Build the vector that holds the parameters of the apodization an the\n# functions required to transform it into a source wavefield\nsrc_field = jnp.zeros(N).astype(jnp.complex64)\nsrc_field = src_field.at[64, 22].set(1.0)\nsrc = FourierSeries(jnp.expand_dims(src_field, -1), domain) * omega\n\n# Plotting\n_ = display_complex_field(src)\n</pre> # Build the vector that holds the parameters of the apodization an the # functions required to transform it into a source wavefield src_field = jnp.zeros(N).astype(jnp.complex64) src_field = src_field.at[64, 22].set(1.0) src = FourierSeries(jnp.expand_dims(src_field, -1), domain) * omega  # Plotting _ = display_complex_field(src) In\u00a0[7]: Copied! <pre># Constructing medium physical properties\nsound_speed = jnp.zeros(N)\nsound_speed = sound_speed.at[20:105, 20:200].set(1.0)\nsound_speed = (\n    sound_speed\n    * (1 - circ_mask(N, 90, [64, 180]))\n    * (1 - circ_mask(N, 50, [64, 22]))\n    * 0.5\n    + 1\n)\nsound_speed = FourierSeries(jnp.expand_dims(sound_speed, -1), domain) * 1540\ndensity = 1  # sound_speed*0 + 1.\nattenuation = 0.0  # density*0\n\nsound_speed = 1500.\nmedium = Medium(domain=domain, sound_speed=sound_speed, density=1000., pml_size=15)\n</pre> # Constructing medium physical properties sound_speed = jnp.zeros(N) sound_speed = sound_speed.at[20:105, 20:200].set(1.0) sound_speed = (     sound_speed     * (1 - circ_mask(N, 90, [64, 180]))     * (1 - circ_mask(N, 50, [64, 22]))     * 0.5     + 1 ) sound_speed = FourierSeries(jnp.expand_dims(sound_speed, -1), domain) * 1540 density = 1  # sound_speed*0 + 1. attenuation = 0.0  # density*0  sound_speed = 1500. medium = Medium(domain=domain, sound_speed=sound_speed, density=1000., pml_size=15) In\u00a0[11]: Copied! <pre>from jwave.acoustics.time_harmonic import helmholtz, helmholtz_solver\n\n@jit\ndef solve_helmholtz(medium):\n    return helmholtz_solver(medium, omega, src)\n\nfield = solve_helmholtz(medium)\n</pre> from jwave.acoustics.time_harmonic import helmholtz, helmholtz_solver  @jit def solve_helmholtz(medium):     return helmholtz_solver(medium, omega, src)  field = solve_helmholtz(medium) In\u00a0[12]: Copied! <pre>_ = display_complex_field(field, max_intensity=2e5)\n</pre> _ = display_complex_field(field, max_intensity=2e5) In\u00a0[14]: Copied! <pre>print(\"Runtime with GMRES\")\n%timeit solve_helmholtz(medium).params.block_until_ready()\n</pre> print(\"Runtime with GMRES\") %timeit solve_helmholtz(medium).params.block_until_ready() <pre>Runtime with GMRES\n1.84 s \u00b1 90.3 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> In\u00a0[16]: Copied! <pre>density = jnp.ones(N)\ndensity = jnp.expand_dims(density.at[:64, 170:].set(1.5), -1)\ndensity = FourierSeries(density, domain)\n\nmedium = Medium(domain=domain, sound_speed=sound_speed, density=density, pml_size=15)\nparams = helmholtz.default_params(src, medium, omega=omega) # Parameters may be different due to different density type\n\ntype(params['fft_u']['k_vec'][0])\n</pre> density = jnp.ones(N) density = jnp.expand_dims(density.at[:64, 170:].set(1.5), -1) density = FourierSeries(density, domain)  medium = Medium(domain=domain, sound_speed=sound_speed, density=density, pml_size=15) params = helmholtz.default_params(src, medium, omega=omega) # Parameters may be different due to different density type  type(params['fft_u']['k_vec'][0]) Out[16]: <pre>jaxlib.xla_extension.ArrayImpl</pre> In\u00a0[17]: Copied! <pre># This is displaying the parameters of the solvers. However, if they are not passed to the solver directly, jwave will automatically using the most appropriate ones.\n# If the input types/sizes are different (for example, adding density to a solver that didn't have it before), it will trigger a recompilation to dispatch a solver that is\n# optimized for the new input types.\nparams.keys()\n</pre> # This is displaying the parameters of the solvers. However, if they are not passed to the solver directly, jwave will automatically using the most appropriate ones. # If the input types/sizes are different (for example, adding density to a solver that didn't have it before), it will trigger a recompilation to dispatch a solver that is # optimized for the new input types. params.keys() Out[17]: <pre>dict_keys(['pml_on_grid', 'fft_u'])</pre> In\u00a0[19]: Copied! <pre># Solve new problem\nfield = solve_helmholtz(medium)\n_ = display_complex_field(field, max_intensity=2e5)\n</pre> # Solve new problem field = solve_helmholtz(medium) _ = display_complex_field(field, max_intensity=2e5) In\u00a0[20]: Copied! <pre>attenuation = jnp.zeros(N)\nattenuation = jnp.expand_dims(attenuation.at[64:110, 125:220].set(100), -1)\n\nmedium = Medium(\n    domain=domain,\n    sound_speed=sound_speed,\n    density=density,\n    attenuation=attenuation,\n    pml_size=15,\n)\n\n# Solve new problem\nfield = solve_helmholtz(medium)\n_ = display_complex_field(field, max_intensity=2e5)\n</pre> attenuation = jnp.zeros(N) attenuation = jnp.expand_dims(attenuation.at[64:110, 125:220].set(100), -1)  medium = Medium(     domain=domain,     sound_speed=sound_speed,     density=density,     attenuation=attenuation,     pml_size=15, )  # Solve new problem field = solve_helmholtz(medium) _ = display_complex_field(field, max_intensity=2e5) In\u00a0[21]: Copied! <pre>print(\"Runtime with GMRES (heterog. density and attenuation)\")\n%timeit solve_helmholtz(medium).params.block_until_ready()\n</pre> print(\"Runtime with GMRES (heterog. density and attenuation)\") %timeit solve_helmholtz(medium).params.block_until_ready() <pre>Runtime with GMRES (heterog. density and attenuation)\n3.3 s \u00b1 158 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre>"},{"location":"notebooks/harmonic/helmholtz_problem.html#helmholtz-problem","title":"Helmholtz problem\u00b6","text":"<p>This example notebook shows how to setup and solve the time-harmonic acoustic propagation problem, which is governed by the Helmholtz equation.</p> <p>The Helmholtz equation is given by Fourier transforming the wave equation in the temporal domain, which gives</p> <p>$$     \\left(\\nabla +\\frac{\\omega^2}{c^2}\\right)\\phi = i \\omega S_M, $$</p> <p>with $P, S_M \\in C^{2}(\\mathbb{C})$.</p> <p>In <code>jwave</code>, the Helmholtz equation solved also takes into account heterogeneous absorption and density, and it is given as $$ \\left(\\frac{\\omega^2}{c_0^2} + \\nabla^2  - \\frac{1}{\\rho_0} \\nabla \\rho_0 \\cdot \\nabla  + \\frac{2i\\omega^3\\alpha_0}{c_0} \\right)P = i \\omega S_M $$ where:</p> <ul> <li>$\\omega =2\\pi f_0$ is the angular frequency, and $f_0$ is the frequency of the wave</li> <li>$\\rho_0$ is the material density</li> <li>$\\alpha_0$ is the attenuation coefficient</li> <li>$S_M$ is the mass source term</li> </ul> <p>Before running the simulation, we'll import the necessary modules and utility functions</p>"},{"location":"notebooks/harmonic/helmholtz_problem.html#heterogeneous-density","title":"Heterogeneous density\u00b6","text":""},{"location":"notebooks/harmonic/helmholtz_problem.html#heterogeneous-attenuation","title":"Heterogeneous attenuation\u00b6","text":""},{"location":"notebooks/harmonic/helmholtz_solver_differentiable.html","title":"Optimizing trough GMRES","text":"In\u00a0[1]: Copied! <pre>import matplotlib as mpl\nmpl.rcParams.update({\n    'font.family': 'serif',\n})\n\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\nimport matplotlib.font_manager as fm\n</pre> import matplotlib as mpl mpl.rcParams.update({     'font.family': 'serif', })  from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar import matplotlib.font_manager as fm In\u00a0[2]: Copied! <pre>from functools import partial\n\nimport jax\nimport numpy as np\nfrom jax import numpy as jnp\nfrom jax import random\n\nkey = random.PRNGKey(42)\n</pre> from functools import partial  import jax import numpy as np from jax import numpy as jnp from jax import random  key = random.PRNGKey(42) In\u00a0[3]: Copied! <pre>import matplotlib\nmatplotlib.rcParams.update(matplotlib.rcParamsDefault)\n</pre> import matplotlib matplotlib.rcParams.update(matplotlib.rcParamsDefault) In\u00a0[4]: Copied! <pre># Defining geometry\nfrom jwave import FourierSeries\nfrom jwave.geometry import Domain, Medium\n\nN = (320, 512)  # Grid size\ndx = (1e-4, 1e-4)  # Spatial resolution\nomega = 1.7e6*2*jnp.pi  # Wavefield omega = 2*pi*f\ntarget = [160, 360]  # Target location\n\n# Making geometry\ndomain = Domain(N, dx)\n\n# Constructing medium physical properties\nsound_speed = jnp.ones(N)\nsound_speed = sound_speed.at[30:80, 50:80].set(1.6)\nsound_speed = sound_speed.at[80:140, 50:100].set(1.4)\nsound_speed = sound_speed.at[140:220, 45:130].set(1.2)\nsound_speed = jnp.expand_dims(sound_speed.at[220:280, 70:100].set(1.5), -1)*1480\nsound_speed = FourierSeries(sound_speed, domain)\n\nmedium = Medium(domain=domain, sound_speed=sound_speed, pml_size=25)\n\n# Build the vector that holds the parameters of the apodization an the\n# functions required to transform it into a source wavefield\ntransmit_phase = jnp.concatenate([jnp.ones((32,)), jnp.ones((32,))])\nposition = list(range(32, 32 + (8 * 32), 8))\n\n\ndef phase_to_apod(phases):\n    dim = len(phases) // 2\n    return jnp.exp(1j * phases[dim:]) / (1 + (phases[:dim]) ** 2)\n\n\ndef phases_to_field(phases, domain):\n    phases = phase_to_apod(phases)\n    src_field = jnp.zeros(domain.N).astype(jnp.complex64)\n    src_field = src_field.at[position, 25].set(phases)\n    return FourierSeries(jnp.expand_dims(src_field, -1), domain)\n\n\nlinear_phase = phases_to_field(transmit_phase, domain)\n</pre> # Defining geometry from jwave import FourierSeries from jwave.geometry import Domain, Medium  N = (320, 512)  # Grid size dx = (1e-4, 1e-4)  # Spatial resolution omega = 1.7e6*2*jnp.pi  # Wavefield omega = 2*pi*f target = [160, 360]  # Target location  # Making geometry domain = Domain(N, dx)  # Constructing medium physical properties sound_speed = jnp.ones(N) sound_speed = sound_speed.at[30:80, 50:80].set(1.6) sound_speed = sound_speed.at[80:140, 50:100].set(1.4) sound_speed = sound_speed.at[140:220, 45:130].set(1.2) sound_speed = jnp.expand_dims(sound_speed.at[220:280, 70:100].set(1.5), -1)*1480 sound_speed = FourierSeries(sound_speed, domain)  medium = Medium(domain=domain, sound_speed=sound_speed, pml_size=25)  # Build the vector that holds the parameters of the apodization an the # functions required to transform it into a source wavefield transmit_phase = jnp.concatenate([jnp.ones((32,)), jnp.ones((32,))]) position = list(range(32, 32 + (8 * 32), 8))   def phase_to_apod(phases):     dim = len(phases) // 2     return jnp.exp(1j * phases[dim:]) / (1 + (phases[:dim]) ** 2)   def phases_to_field(phases, domain):     phases = phase_to_apod(phases)     src_field = jnp.zeros(domain.N).astype(jnp.complex64)     src_field = src_field.at[position, 25].set(phases)     return FourierSeries(jnp.expand_dims(src_field, -1), domain)   linear_phase = phases_to_field(transmit_phase, domain) In\u00a0[5]: Copied! <pre>from matplotlib import pyplot as plt\n\nfrom jwave.utils import display_complex_field, show_positive_field\n\nplt.figure(figsize=(8, 5))\n\nplt.imshow(medium.sound_speed.on_grid)\nplt.colorbar()\nplt.title(\"Sound speed map\")\nplt.scatter([25] * len(position), position, marker=\".\", label=\"Transducers\")\nplt.scatter(target[1], target[0], label=\"Target\", marker='x')\n</pre> from matplotlib import pyplot as plt  from jwave.utils import display_complex_field, show_positive_field  plt.figure(figsize=(8, 5))  plt.imshow(medium.sound_speed.on_grid) plt.colorbar() plt.title(\"Sound speed map\") plt.scatter([25] * len(position), position, marker=\".\", label=\"Transducers\") plt.scatter(target[1], target[0], label=\"Target\", marker='x') Out[5]: <pre>&lt;matplotlib.collections.PathCollection at 0x7f40bb45c310&gt;</pre> <p>We will now extract the default parameters of the helmholtz solver. This is not strictly necessary, but in 3D simulation reduces the compilation time at the expenses of a slightly larger runtime: see https://github.com/google/jax/issues?q=constant+folding</p> In\u00a0[\u00a0]: Copied! <pre>from jax import jit\n\nfrom jwave.acoustics.operators import helmholtz\nfrom jwave.acoustics.time_harmonic import helmholtz_solver, helmholtz_solver_verbose\n\nop_params = helmholtz.default_params(linear_phase, medium, omega=1.0)\n</pre> from jax import jit  from jwave.acoustics.operators import helmholtz from jwave.acoustics.time_harmonic import helmholtz_solver, helmholtz_solver_verbose  op_params = helmholtz.default_params(linear_phase, medium, omega=1.0) In\u00a0[17]: Copied! <pre>print(\"Operator parameters: \" + str(list(op_params.keys())))\n\nplt.imshow(op_params[\"pml_on_grid\"][0].on_grid[...,0].imag)\nplt.title(\"Imaginary component of the 1st PML coordinate field\")\nplt.show()\n</pre> print(\"Operator parameters: \" + str(list(op_params.keys())))  plt.imshow(op_params[\"pml_on_grid\"][0].on_grid[...,0].imag) plt.title(\"Imaginary component of the 1st PML coordinate field\") plt.show() <pre>Operator parameters: ['pml_on_grid', 'fft_u']\n</pre> In\u00a0[18]: Copied! <pre>@jit\ndef fixed_medium_solver(src_field, op_params, guess=None, tol=1e-3):\n    return helmholtz_solver(\n        medium, omega, src_field, guess=guess, tol=tol, params=op_params\n    )\n\nfield = fixed_medium_solver(linear_phase, op_params)\n_ = display_complex_field(field, figsize=(20, 20))\n</pre> @jit def fixed_medium_solver(src_field, op_params, guess=None, tol=1e-3):     return helmholtz_solver(         medium, omega, src_field, guess=guess, tol=tol, params=op_params     )  field = fixed_medium_solver(linear_phase, op_params) _ = display_complex_field(field, figsize=(20, 20)) <p>We can now define our loss function $L(\\mathbf a)$ and perform gradient descent, to reach a local minima.</p> <p>Note that this is possible because the GMRES implementation, which computes the solution of the Helmholtz problem, is differentiable.</p> In\u00a0[19]: Copied! <pre>from jax import value_and_grad, vmap\n</pre> from jax import value_and_grad, vmap In\u00a0[20]: Copied! <pre>def loss(field):\n    field = field.on_grid\n    return -jnp.sum(jnp.abs(field[target[0], target[1]]))\n\ndef get_field(transmit_phase, tol, guess, op_params):\n    transmit_field = phases_to_field(transmit_phase, domain)\n    return fixed_medium_solver(transmit_field, op_params, guess, tol)\n\ndef full_loss(transmit_phase, tol, guess, op_params):\n    field = get_field(transmit_phase, tol, guess, op_params)\n    return loss(field), field\n\nloss_with_grad = value_and_grad(full_loss, has_aux=True)\n</pre> def loss(field):     field = field.on_grid     return -jnp.sum(jnp.abs(field[target[0], target[1]]))  def get_field(transmit_phase, tol, guess, op_params):     transmit_field = phases_to_field(transmit_phase, domain)     return fixed_medium_solver(transmit_field, op_params, guess, tol)  def full_loss(transmit_phase, tol, guess, op_params):     field = get_field(transmit_phase, tol, guess, op_params)     return loss(field), field  loss_with_grad = value_and_grad(full_loss, has_aux=True) <p>\u26a0\ufe0f Run the next cell only if you don't have <code>tqdm</code> installed, otherwise it will be reinstalled</p> In\u00a0[21]: Copied! <pre>!pip install tqdm\n</pre> !pip install tqdm <pre>Requirement already satisfied: tqdm in /home/antonio/anaconda3/envs/jwave/lib/python3.11/site-packages (4.65.0)\n</pre> In\u00a0[\u00a0]: Copied! <pre>from jax import jit\nfrom jax.example_libraries import optimizers\nfrom tqdm import tqdm\n\nlosshistory = []\n\ninit_fun, update_fun, get_params = optimizers.adam(0.1, b1=0.9, b2=0.9)\nopt_state = init_fun(transmit_phase)\n\n@partial(jit, static_argnums=(1,))\ndef update(opt_state, tol, guess, op_params):\n    loss_and_field, gradient = loss_with_grad(\n        get_params(opt_state), tol, guess, op_params\n    )\n    lossval = loss_and_field[0]\n    field = loss_and_field[1]\n    return lossval, field, update_fun(k, gradient, opt_state)\n\n\npbar = tqdm(range(100))\ntol = 1e-3\nguess = None\nfor k in pbar:\n    lossval, new_field, opt_state = update(opt_state, tol, guess, op_params)\n\n    # For logging\n    pbar.set_description(\"Ampl: {:01.4f}\".format(-lossval))\n    losshistory.append(lossval)\n\ntransmit_phase = get_params(opt_state)\n</pre> from jax import jit from jax.example_libraries import optimizers from tqdm import tqdm  losshistory = []  init_fun, update_fun, get_params = optimizers.adam(0.1, b1=0.9, b2=0.9) opt_state = init_fun(transmit_phase)  @partial(jit, static_argnums=(1,)) def update(opt_state, tol, guess, op_params):     loss_and_field, gradient = loss_with_grad(         get_params(opt_state), tol, guess, op_params     )     lossval = loss_and_field[0]     field = loss_and_field[1]     return lossval, field, update_fun(k, gradient, opt_state)   pbar = tqdm(range(100)) tol = 1e-3 guess = None for k in pbar:     lossval, new_field, opt_state = update(opt_state, tol, guess, op_params)      # For logging     pbar.set_description(\"Ampl: {:01.4f}\".format(-lossval))     losshistory.append(lossval)  transmit_phase = get_params(opt_state) <p>Following is the wavefield for the optimized apodization</p> In\u00a0[23]: Copied! <pre>fig, ax = plt.subplots(1,2,figsize=(10,3), dpi=200)\n\nim1 = ax[0].imshow(medium.sound_speed.on_grid, cmap=\"PuBu\")\ncbar = fig.colorbar(im1, ax=ax[0])\ncbar.ax.get_yaxis().labelpad = 15\nax[0].scatter([25] * len(position), position, marker=\".\", color=\"black\", label=\"Transducers\")\nax[0].scatter(target[1], target[0], label=\"Target\", color=\"green\", marker='o')\nax[0].axis('off')\nax[0].set_title('Speed of sound map')\nax[0].legend()\n\n# Scale bar\nfontprops = fm.FontProperties(size=12)\nscalebar = AnchoredSizeBar(\n    ax[0].transData,\n    100, '1 cm', 'lower right', \n    pad=0.3,\n    color='black',\n    frameon=False,\n    size_vertical=2,\n    fontproperties=fontprops)\nax[0].add_artist(scalebar)\n\nim1 = ax[1].imshow(jnp.abs(new_field.on_grid), cmap=\"inferno\", vmax=0.5)\ncbar = fig.colorbar(im1, ax=ax[1])\ncbar.ax.get_yaxis().labelpad = 15\nax[1].axis('off')\nax[1].set_title('Focused field amplitude')\nax[1].scatter(target[1], target[0], label=\"Target\", color=\"green\", marker='o')\n\nfig.tight_layout()\n\nplt.savefig(\"harmonic_focusing.pdf\")\n</pre> fig, ax = plt.subplots(1,2,figsize=(10,3), dpi=200)  im1 = ax[0].imshow(medium.sound_speed.on_grid, cmap=\"PuBu\") cbar = fig.colorbar(im1, ax=ax[0]) cbar.ax.get_yaxis().labelpad = 15 ax[0].scatter([25] * len(position), position, marker=\".\", color=\"black\", label=\"Transducers\") ax[0].scatter(target[1], target[0], label=\"Target\", color=\"green\", marker='o') ax[0].axis('off') ax[0].set_title('Speed of sound map') ax[0].legend()  # Scale bar fontprops = fm.FontProperties(size=12) scalebar = AnchoredSizeBar(     ax[0].transData,     100, '1 cm', 'lower right',      pad=0.3,     color='black',     frameon=False,     size_vertical=2,     fontproperties=fontprops) ax[0].add_artist(scalebar)  im1 = ax[1].imshow(jnp.abs(new_field.on_grid), cmap=\"inferno\", vmax=0.5) cbar = fig.colorbar(im1, ax=ax[1]) cbar.ax.get_yaxis().labelpad = 15 ax[1].axis('off') ax[1].set_title('Focused field amplitude') ax[1].scatter(target[1], target[0], label=\"Target\", color=\"green\", marker='o')  fig.tight_layout()  plt.savefig(\"harmonic_focusing.pdf\") <p>Lastly, we can visualize the learned apodization</p> In\u00a0[11]: Copied! <pre>plt.figure(figsize=(10, 3))\nplt.plot(jnp.real(phase_to_apod(transmit_phase)))\nplt.plot(jnp.imag(phase_to_apod(transmit_phase)))\n# plt.plot(jnp.abs(phase_to_apod(transmit_phase)), \"r.\")\nplt.title(\"Apodization\")\n</pre> plt.figure(figsize=(10, 3)) plt.plot(jnp.real(phase_to_apod(transmit_phase))) plt.plot(jnp.imag(phase_to_apod(transmit_phase))) # plt.plot(jnp.abs(phase_to_apod(transmit_phase)), \"r.\") plt.title(\"Apodization\") Out[11]: <pre>Text(0.5, 1.0, 'Apodization')</pre> In\u00a0[12]: Copied! <pre>plt.plot(-jnp.array(losshistory))\nplt.title(\"Amplitude at target location\")\nplt.xlabel(\"Optimization step\")\nplt.show()\n</pre> plt.plot(-jnp.array(losshistory)) plt.title(\"Amplitude at target location\") plt.xlabel(\"Optimization step\") plt.show() In\u00a0[13]: Copied! <pre>from jax import random\n\nfrom jwave.signal_processing import smooth\n\nkey = random.PRNGKey(12)\n</pre> from jax import random  from jwave.signal_processing import smooth  key = random.PRNGKey(12) In\u00a0[14]: Copied! <pre>target = [60, 360]  # Target location\n\n# Constructing medium physical properties\ndef get_sos(segments, start_point=30, height=4, width=30):\n    sos = jnp.ones(N)\n    for k in range(len(segments)):\n        sos = sos.at[\n            start_point + k * height : start_point + (k + 1) * height, 50 : 50 + width\n        ].add(jax.nn.sigmoid(segments[k]))\n    return FourierSeries(jnp.expand_dims(sos, -1), domain)\n</pre> target = [60, 360]  # Target location  # Constructing medium physical properties def get_sos(segments, start_point=30, height=4, width=30):     sos = jnp.ones(N)     for k in range(len(segments)):         sos = sos.at[             start_point + k * height : start_point + (k + 1) * height, 50 : 50 + width         ].add(jax.nn.sigmoid(segments[k]))     return FourierSeries(jnp.expand_dims(sos, -1), domain) In\u00a0[15]: Copied! <pre>key, _ = random.split(key)\nsos_control_points = random.normal(key, shape=(65,))\nsos = get_sos(sos_control_points)\n</pre> key, _ = random.split(key) sos_control_points = random.normal(key, shape=(65,)) sos = get_sos(sos_control_points) In\u00a0[16]: Copied! <pre>show_positive_field(sos, aspect=\"equal\")\n</pre> show_positive_field(sos, aspect=\"equal\") In\u00a0[17]: Copied! <pre>from jwave.acoustics.operators import helmholtz\n\nmedium = Medium(domain, sound_speed=get_sos(sos_control_points))\nop_params = helmholtz.default_params(linear_phase, medium, omega=1.0)\nprint(op_params.keys())\n</pre> from jwave.acoustics.operators import helmholtz  medium = Medium(domain, sound_speed=get_sos(sos_control_points)) op_params = helmholtz.default_params(linear_phase, medium, omega=1.0) print(op_params.keys()) <pre>dict_keys(['fft_u', 'pml_on_grid'])\n</pre> In\u00a0[18]: Copied! <pre>from jax import value_and_grad\n\nfrom jwave.acoustics.time_harmonic import helmholtz_solver\n\n\ndef loss(field):\n    field = field.on_grid\n    return -jnp.sum(jnp.abs(field[target[0], target[1]]))\n\n\ndef get_field(params, tol, field):\n    medium = Medium(domain, sound_speed=get_sos(params))\n    return helmholtz_solver(\n        medium, 1.0, linear_phase, guess=field, tol=tol, checkpoint=False\n    )\n\n\ndef full_loss(params, tol, field):\n    field = get_field(params, tol, field)\n    return loss(field), field\n\n\nloss_with_grad = value_and_grad(full_loss, has_aux=True)\n</pre> from jax import value_and_grad  from jwave.acoustics.time_harmonic import helmholtz_solver   def loss(field):     field = field.on_grid     return -jnp.sum(jnp.abs(field[target[0], target[1]]))   def get_field(params, tol, field):     medium = Medium(domain, sound_speed=get_sos(params))     return helmholtz_solver(         medium, 1.0, linear_phase, guess=field, tol=tol, checkpoint=False     )   def full_loss(params, tol, field):     field = get_field(params, tol, field)     return loss(field), field   loss_with_grad = value_and_grad(full_loss, has_aux=True) In\u00a0[19]: Copied! <pre>from jax import jit\nfrom jax.example_libraries import optimizers\nfrom tqdm import tqdm\n\nlosshistory = []\n\nkey, _ = random.split(key)\nsos_vector = random.normal(key, shape=(65,))\n\ninit_fun, update_fun, get_params = optimizers.adam(0.1, b1=0.9, b2=0.9)\nopt_state = init_fun(sos_control_points)\n\n\n@jit\ndef update(opt_state, tol, field):\n    loss_and_field, gradient = loss_with_grad(get_params(opt_state), tol, field)\n    lossval = loss_and_field[0]\n    field = loss_and_field[1]\n    return lossval, field, update_fun(k, gradient, opt_state)\n\n\npbar = tqdm(range(100))\ntol = 1e-3\nfield = -linear_phase\nfor k in pbar:\n    lossval, field, opt_state = update(opt_state, tol, field)\n\n    # For logging\n    pbar.set_description(\"Tol: {} Ampl: {:01.4f}\".format(tol, -lossval))\n    losshistory.append(lossval)\n\ntransmit_phase = get_params(opt_state)\n</pre> from jax import jit from jax.example_libraries import optimizers from tqdm import tqdm  losshistory = []  key, _ = random.split(key) sos_vector = random.normal(key, shape=(65,))  init_fun, update_fun, get_params = optimizers.adam(0.1, b1=0.9, b2=0.9) opt_state = init_fun(sos_control_points)   @jit def update(opt_state, tol, field):     loss_and_field, gradient = loss_with_grad(get_params(opt_state), tol, field)     lossval = loss_and_field[0]     field = loss_and_field[1]     return lossval, field, update_fun(k, gradient, opt_state)   pbar = tqdm(range(100)) tol = 1e-3 field = -linear_phase for k in pbar:     lossval, field, opt_state = update(opt_state, tol, field)      # For logging     pbar.set_description(\"Tol: {} Ampl: {:01.4f}\".format(tol, -lossval))     losshistory.append(lossval)  transmit_phase = get_params(opt_state) <pre>Tol: 0.001 Ampl: 0.3812: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [10:26&lt;00:00,  6.26s/it]\n</pre> In\u00a0[25]: Copied! <pre>plt.plot(-jnp.array(losshistory))  #\nplt.title(\"Amplitude at target location\")\n</pre> plt.plot(-jnp.array(losshistory))  # plt.title(\"Amplitude at target location\") Out[25]: <pre>Text(0.5, 1.0, 'Amplitude at target location')</pre> In\u00a0[26]: Copied! <pre>opt_sos_vector = get_params(opt_state)\n</pre> opt_sos_vector = get_params(opt_state) In\u00a0[27]: Copied! <pre>plt.figure(figsize=(10, 6))\n\nplt.imshow(jnp.abs(field.on_grid), vmax=0.35, cmap=\"inferno\")\nplt.colorbar()\nplt.scatter(target[1], target[0])\n</pre> plt.figure(figsize=(10, 6))  plt.imshow(jnp.abs(field.on_grid), vmax=0.35, cmap=\"inferno\") plt.colorbar() plt.scatter(target[1], target[0]) Out[27]: <pre>&lt;matplotlib.collections.PathCollection at 0x7f529118a830&gt;</pre> In\u00a0[28]: Copied! <pre>sos = get_sos(opt_sos_vector)\nplt.figure(figsize=(8, 8))\nplt.imshow(sos.on_grid[..., 0])\nplt.title(\"Sound speed map\")\nplt.scatter(target[1], target[0], label=\"Target\")\nplt.legend()\n</pre> sos = get_sos(opt_sos_vector) plt.figure(figsize=(8, 8)) plt.imshow(sos.on_grid[..., 0]) plt.title(\"Sound speed map\") plt.scatter(target[1], target[0], label=\"Target\") plt.legend() Out[28]: <pre>&lt;matplotlib.legend.Legend at 0x7f5291216c80&gt;</pre> In\u00a0[29]: Copied! <pre>plt.plot(sos.on_grid[..., 64, 0])\n</pre> plt.plot(sos.on_grid[..., 64, 0]) Out[29]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f52a19abca0&gt;]</pre>"},{"location":"notebooks/harmonic/helmholtz_solver_differentiable.html#optimizing-trough-gmres","title":"Optimizing trough GMRES\u00b6","text":"<p>This example demostrates how it is possible to take advantage of the <code>implicit function theorem</code> to differentiate trough a fixed point algorithm with $O(1)$ memory requirement, Here, the iterative solver is given by GMRES, which is used to solve the Helmholtz equation.</p> <p>A great discussion about taking derivatives of a generic fixed-point algorithm is given in the DEQ paper</p>"},{"location":"notebooks/harmonic/helmholtz_solver_differentiable.html#helmholtz-equation","title":"Helmholtz equation\u00b6","text":"<p>We'll assume to transmit waves from a set of $n$ transducers, which act as monopole sources: that means that we can define an apodization vector</p> <p>$$ \\mathbf a = (a_0, \\dots, a_n), \\qquad a_i \\in \\mathbb{C}, \\; \\|a_i\\| &lt; 1 $$</p> <p>such that $\\rho(\\mathbf a)$ is the transmit wavefield. The unit norm constraint is needed to enforce the fact that each transducer has an upper limit on the maximum power it can transmit.</p> <p>We could use several methods to represent this vector and its constraint. Here, we use</p> <p>$$ a_j(\\rho_j, \\theta_j) = \\frac{e^{i\\theta_j}}{1 + \\rho_j^2}. $$</p>"},{"location":"notebooks/harmonic/helmholtz_solver_differentiable.html#focusing","title":"Focusing\u00b6","text":"<p>Often, we want to find the apodization vector which returns a field having certain properties. For example, in a neurostimulation session we may want to maximize the acoustic power delivered to a certain spot, while keeping the acoustic field below an arbitrary treshold in another region.</p> <p>Let's call $\\mathbf p\\in\\mathbb{R}^2$ the point where we want to maximize the wavefield. For a field $\\phi(\\mathbf x,\\mathbf a)$ generated by the apodization $\\mathbf a$, the optimal apodization is then given by</p> <p>$$ \\hat {\\mathbf a} = \\operatorname*{arg\\,max}_{\\mathbf a} \\|\\phi(\\mathbf p, \\mathbf a) \\| $$</p> <p>We start by setting up the simulation:</p>"},{"location":"notebooks/harmonic/helmholtz_solver_differentiable.html#speed-of-sound-gradients","title":"Speed of sound gradients\u00b6","text":"<p>Gradients can be evaluated with respect to every parameter of the simulation. In this example, we will keep the source term fixed and vary the density of an acoustic lens to focus on a target.</p>"},{"location":"notebooks/ivp/3d.html","title":"3D simulations","text":"In\u00a0[1]: Copied! <pre>from matplotlib import pyplot as plt\n\nfrom jwave.geometry import Domain\nfrom jwave.utils import show_field, show_positive_field\n\nN, dx = (64, 64, 64), (0.1e-3, 0.1e-3, 0.1e-3)\ndomain = Domain(N, dx)\n</pre> from matplotlib import pyplot as plt  from jwave.geometry import Domain from jwave.utils import show_field, show_positive_field  N, dx = (64, 64, 64), (0.1e-3, 0.1e-3, 0.1e-3) domain = Domain(N, dx) In\u00a0[2]: Copied! <pre>from jax import numpy as jnp\n\nfrom jwave.geometry import Medium, Sensors, TimeAxis, fibonacci_sphere, sphere_mask\n\nmedium = Medium(domain=domain, sound_speed=1500.0)\n\ntime_axis = TimeAxis.from_medium(medium, cfl=0.3)\noutput_time_axis = TimeAxis(time_axis.dt * 20, time_axis.t_end // 2)\n\n# sensors\nnum_sensors = 64\nx, y, z = fibonacci_sphere(num_sensors, 20, (32, 32, 32))\nsensors_positions = (jnp.array(x), jnp.array(y), jnp.array(z))\nsensors = Sensors(positions=sensors_positions)\n</pre> from jax import numpy as jnp  from jwave.geometry import Medium, Sensors, TimeAxis, fibonacci_sphere, sphere_mask  medium = Medium(domain=domain, sound_speed=1500.0)  time_axis = TimeAxis.from_medium(medium, cfl=0.3) output_time_axis = TimeAxis(time_axis.dt * 20, time_axis.t_end // 2)  # sensors num_sensors = 64 x, y, z = fibonacci_sphere(num_sensors, 20, (32, 32, 32)) sensors_positions = (jnp.array(x), jnp.array(y), jnp.array(z)) sensors = Sensors(positions=sensors_positions) <pre>No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> In\u00a0[3]: Copied! <pre>from matplotlib import pyplot as plt\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_subplot(projection=\"3d\")\nax.scatter(x, y, z, marker=\"o\", color=\"black\")\nax.set_title(\"Sensor locations\")\n</pre> from matplotlib import pyplot as plt  fig = plt.figure(figsize=(8, 8)) ax = fig.add_subplot(projection=\"3d\") ax.scatter(x, y, z, marker=\"o\", color=\"black\") ax.set_title(\"Sensor locations\") Out[3]: <pre>Text(0.5, 0.92, 'Sensor locations')</pre> In\u00a0[4]: Copied! <pre>from jwave import FourierSeries\nfrom jwave.utils import show_field\n\n# Initial pressure is a sphere\np0 = jnp.zeros(domain.N)\np0 = (\n    sphere_mask(domain.N, 5, (32, 36, 36)) * 1.0\n    + sphere_mask(domain.N, 8, (32, 30, 30)) * 0.5\n)\np0 = jnp.expand_dims(p0, -1)\n\np0 = FourierSeries(p0, domain)\np0_slice = p0.on_grid[32]\n\nshow_field(p0_slice, \"Section of the initial pressure\")\n</pre> from jwave import FourierSeries from jwave.utils import show_field  # Initial pressure is a sphere p0 = jnp.zeros(domain.N) p0 = (     sphere_mask(domain.N, 5, (32, 36, 36)) * 1.0     + sphere_mask(domain.N, 8, (32, 30, 30)) * 0.5 ) p0 = jnp.expand_dims(p0, -1)  p0 = FourierSeries(p0, domain) p0_slice = p0.on_grid[32]  show_field(p0_slice, \"Section of the initial pressure\") In\u00a0[5]: Copied! <pre>from jax import jit\n\nfrom jwave.acoustics import simulate_wave_propagation\n\n@jit\ndef compiled_simulator(p0):\n    return simulate_wave_propagation(medium, time_axis, p0=p0, sensors=sensors)\n</pre> from jax import jit  from jwave.acoustics import simulate_wave_propagation  @jit def compiled_simulator(p0):     return simulate_wave_propagation(medium, time_axis, p0=p0, sensors=sensors) In\u00a0[6]: Copied! <pre>pressure = compiled_simulator(p0)\n</pre> pressure = compiled_simulator(p0) In\u00a0[7]: Copied! <pre>plt.imshow(pressure[..., 0].T, aspect=\"auto\", cmap=\"RdBu\", vmin=-0.1, vmax=0.1)\nplt.title(\"Sensors traces\")\n</pre> plt.imshow(pressure[..., 0].T, aspect=\"auto\", cmap=\"RdBu\", vmin=-0.1, vmax=0.1) plt.title(\"Sensors traces\") Out[7]: <pre>Text(0.5, 1.0, 'Sensors traces')</pre> In\u00a0[8]: Copied! <pre>plt.plot(pressure[:, 10])\n</pre> plt.plot(pressure[:, 10]) Out[8]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f221441e890&gt;]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/ivp/3d.html#3d-simulations","title":"3D simulations\u00b6","text":"<p>Running 3D simulations simply requires to append an extra dimension to all parameters.</p>"},{"location":"notebooks/ivp/custom_sensors.html","title":"Custom sensors","text":"In\u00a0[1]: Copied! <pre>from jax import jit\nfrom jax import numpy as jnp\nfrom matplotlib import pyplot as plt\n\nfrom jwave import FourierSeries\nfrom jwave.acoustics import simulate_wave_propagation\nfrom jwave.geometry import *\nfrom jwave.geometry import circ_mask\nfrom jwave.utils import show_field\n\ndomain = Domain((128, 128), (0.1e-3, 0.1e-3))\nmedium = Medium(domain=domain, sound_speed=1500.0)\ntime_axis = TimeAxis.from_medium(medium, cfl=0.3)\n</pre> from jax import jit from jax import numpy as jnp from matplotlib import pyplot as plt  from jwave import FourierSeries from jwave.acoustics import simulate_wave_propagation from jwave.geometry import * from jwave.geometry import circ_mask from jwave.utils import show_field  domain = Domain((128, 128), (0.1e-3, 0.1e-3)) medium = Medium(domain=domain, sound_speed=1500.0) time_axis = TimeAxis.from_medium(medium, cfl=0.3) <pre>WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> In\u00a0[2]: Copied! <pre># Defining the initial pressure\n\nN = domain.N\nmask1 = circ_mask(N, 8, (50, 50))\nmask2 = circ_mask(N, 5, (80, 60))\nmask3 = circ_mask(N, 10, (64, 64))\nmask4 = circ_mask(N, 30, (64, 64))\np0 = 5.0 * mask1 + 3.0 * mask2 + 4.0 * mask3 + 0.5 * mask4\n\np0 = 1.0 * jnp.expand_dims(p0, -1)\np0 = FourierSeries(p0, domain)\n</pre> # Defining the initial pressure  N = domain.N mask1 = circ_mask(N, 8, (50, 50)) mask2 = circ_mask(N, 5, (80, 60)) mask3 = circ_mask(N, 10, (64, 64)) mask4 = circ_mask(N, 30, (64, 64)) p0 = 5.0 * mask1 + 3.0 * mask2 + 4.0 * mask3 + 0.5 * mask4  p0 = 1.0 * jnp.expand_dims(p0, -1) p0 = FourierSeries(p0, domain) In\u00a0[3]: Copied! <pre>show_field(p0)\nplt.title(\"Initial pressure\")\n</pre> show_field(p0) plt.title(\"Initial pressure\") Out[3]: <pre>Text(0.5, 1.0, 'Initial pressure')</pre> In\u00a0[4]: Copied! <pre>def sensor_func(p, u, rho):\n    position = (64, 24)\n    # Returns the maximum velocity on a 16x16 neighborhood at\n    # each timestep\n    v = u.on_grid[position[0] : position[0] + 16, position[1] : position[1] + 16]\n    return jnp.amax(v, axis=(0, 1))\n</pre> def sensor_func(p, u, rho):     position = (64, 24)     # Returns the maximum velocity on a 16x16 neighborhood at     # each timestep     v = u.on_grid[position[0] : position[0] + 16, position[1] : position[1] + 16]     return jnp.amax(v, axis=(0, 1)) In\u00a0[5]: Copied! <pre>@jit\ndef compiled_simulator(medium, p0):\n    return simulate_wave_propagation(medium, time_axis, p0=p0, sensors=sensor_func)\n</pre> @jit def compiled_simulator(medium, p0):     return simulate_wave_propagation(medium, time_axis, p0=p0, sensors=sensor_func) In\u00a0[6]: Copied! <pre>sensors_data = compiled_simulator(medium, p0)\n</pre> sensors_data = compiled_simulator(medium, p0) In\u00a0[7]: Copied! <pre>sensors_data.shape\n</pre> sensors_data.shape Out[7]: <pre>(599, 2)</pre> In\u00a0[8]: Copied! <pre>plt.figure(figsize=(8, 3), dpi=100)\nplt.plot(sensors_data[:, 0], label=\"Max $v_x$\", color=\"k\")\nplt.plot(sensors_data[:, 1], label=\"Max $v_y$\", color=\"k\", linestyle=\"-.\")\nplt.legend()\n</pre> plt.figure(figsize=(8, 3), dpi=100) plt.plot(sensors_data[:, 0], label=\"Max $v_x$\", color=\"k\") plt.plot(sensors_data[:, 1], label=\"Max $v_y$\", color=\"k\", linestyle=\"-.\") plt.legend() Out[8]: <pre>&lt;matplotlib.legend.Legend at 0x7f9a082df880&gt;</pre>"},{"location":"notebooks/ivp/custom_sensors.html#custom-sensors","title":"Custom sensors\u00b6","text":""},{"location":"notebooks/ivp/different_discretizations.html","title":"Different discretizations","text":"In\u00a0[1]: Copied! <pre>import matplotlib as mpl\nmpl.rcParams.update({\n    'font.family': 'serif',\n})\n</pre> import matplotlib as mpl mpl.rcParams.update({     'font.family': 'serif', }) In\u00a0[2]: Copied! <pre>from jwave.geometry import Domain, Medium, TimeAxis, circ_mask\nfrom jwave.acoustics.time_varying import simulate_wave_propagation\nfrom jwave import FiniteDifferences, FourierSeries\nfrom jwave.signal_processing import smooth\n\nfrom jax import numpy as jnp\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport jax\n\nimport matplotlib\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\nimport matplotlib.font_manager as fm\n</pre> from jwave.geometry import Domain, Medium, TimeAxis, circ_mask from jwave.acoustics.time_varying import simulate_wave_propagation from jwave import FiniteDifferences, FourierSeries from jwave.signal_processing import smooth  from jax import numpy as jnp from matplotlib import pyplot as plt import numpy as np import jax  import matplotlib from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar import matplotlib.font_manager as fm In\u00a0[3]: Copied! <pre>domain = Domain((256,256), (0.1e-3,0.1e-3))\n\n# Heterogeneous sound speed\nsound_speed = np.ones(domain.N) * 1500.0\nsound_speed[100:180, 85:200] = 2300.0\n\n# Smoothed initial pressure distribution\nNx = domain.N\np0 = 5.0 * circ_mask(Nx, 5, (128, 40))\np0 = smooth(p0)\n\n# Getting time axis\nmedium = Medium(domain, sound_speed, pml_size=16)\ntime_axis = TimeAxis.from_medium(medium, cfl=0.05, t_end=8e-6)\n</pre> domain = Domain((256,256), (0.1e-3,0.1e-3))  # Heterogeneous sound speed sound_speed = np.ones(domain.N) * 1500.0 sound_speed[100:180, 85:200] = 2300.0  # Smoothed initial pressure distribution Nx = domain.N p0 = 5.0 * circ_mask(Nx, 5, (128, 40)) p0 = smooth(p0)  # Getting time axis medium = Medium(domain, sound_speed, pml_size=16) time_axis = TimeAxis.from_medium(medium, cfl=0.05, t_end=8e-6) In\u00a0[4]: Copied! <pre>@jax.jit\ndef run_simulation(p0, sound_speed):\n    medium = Medium(domain, sound_speed, pml_size=16)\n    return simulate_wave_propagation(\n      medium,\n      time_axis,\n      p0=p0,\n    )\n</pre> @jax.jit def run_simulation(p0, sound_speed):     medium = Medium(domain, sound_speed, pml_size=16)     return simulate_wave_propagation(       medium,       time_axis,       p0=p0,     ) In\u00a0[5]: Copied! <pre>p0_fd = FiniteDifferences(np.expand_dims(p0, -1), domain, accuracy=8)\nsos_fd = FiniteDifferences(np.expand_dims(sound_speed, -1), domain, accuracy=8)\n\npred_fields_fd = run_simulation(p0_fd, sos_fd)\n</pre> p0_fd = FiniteDifferences(np.expand_dims(p0, -1), domain, accuracy=8) sos_fd = FiniteDifferences(np.expand_dims(sound_speed, -1), domain, accuracy=8)  pred_fields_fd = run_simulation(p0_fd, sos_fd) In\u00a0[6]: Copied! <pre>%timeit run_simulation(p0_fd, sos_fd).params.block_until_ready()\n</pre> %timeit run_simulation(p0_fd, sos_fd).params.block_until_ready() <pre>434 ms \u00b1 561 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> In\u00a0[7]: Copied! <pre>p0_fourier = FourierSeries(np.expand_dims(p0, -1), domain)\nsos_fourier = FourierSeries(np.expand_dims(sound_speed, -1), domain)\n\npred_fields_fourier = run_simulation(p0_fourier, sos_fourier)\n</pre> p0_fourier = FourierSeries(np.expand_dims(p0, -1), domain) sos_fourier = FourierSeries(np.expand_dims(sound_speed, -1), domain)  pred_fields_fourier = run_simulation(p0_fourier, sos_fourier) In\u00a0[8]: Copied! <pre>%timeit run_simulation(p0_fourier, sos_fourier).params.block_until_ready()\n</pre> %timeit run_simulation(p0_fourier, sos_fourier).params.block_until_ready() <pre>614 ms \u00b1 823 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> In\u00a0[\u00a0]: Copied! <pre>fig, ax = plt.subplots(1,3,figsize=(9,2.5), dpi=200)\n\nim1 = ax[0].imshow(pred_fields_fd[-1].on_grid, cmap=\"RdBu_r\", vmin=-0.7, vmax=0.7)\ncbar = fig.colorbar(im1, ax=ax[0])\ncbar.ax.get_yaxis().labelpad = 15\ncbar.ax.set_ylabel('A.U.', rotation=270)\nax[0].axis('off')\nax[0].set_title('(a) FiniteDifferences')\n\nim2 = ax[1].imshow(pred_fields_fourier[-1].on_grid, cmap=\"RdBu_r\", vmin=-0.7, vmax=0.7)\ncbar = fig.colorbar(im2, ax=ax[1])\ncbar.ax.get_yaxis().labelpad = 15\ncbar.ax.set_ylabel('A.U.', rotation=270)\nax[1].axis('off')\nax[1].set_title('(b) FourierSeries')\n\nerror = jnp.abs((pred_fields_fourier[-1] - pred_fields_fd[-1]).on_grid)\nmax_value = jnp.max(pred_fields_fourier[-1].on_grid)\nerror = 100*error/max_value\nim_error = ax[2].imshow(error, cmap=\"Reds\")\ncbar = fig.colorbar(im_error, ax=ax[2])\ncbar.ax.get_yaxis().labelpad = 15\ncbar.ax.set_ylabel('%', rotation=270)\nax[2].axis('off')\nax[2].set_title('(c) Absolute error (%)')\n\n# Scale bar\nfontprops = fm.FontProperties(size=12)\nscalebar = AnchoredSizeBar(\n    ax[0].transData,\n    100, '1 cm', 'lower right', \n    pad=0.3,\n    color='black',\n    frameon=False,\n    size_vertical=2,\n    fontproperties=fontprops)\nax[0].add_artist(scalebar)\n\nfig.tight_layout()\n\nplt.savefig(\"fourier_fd_comparison.pdf\")\n</pre> fig, ax = plt.subplots(1,3,figsize=(9,2.5), dpi=200)  im1 = ax[0].imshow(pred_fields_fd[-1].on_grid, cmap=\"RdBu_r\", vmin=-0.7, vmax=0.7) cbar = fig.colorbar(im1, ax=ax[0]) cbar.ax.get_yaxis().labelpad = 15 cbar.ax.set_ylabel('A.U.', rotation=270) ax[0].axis('off') ax[0].set_title('(a) FiniteDifferences')  im2 = ax[1].imshow(pred_fields_fourier[-1].on_grid, cmap=\"RdBu_r\", vmin=-0.7, vmax=0.7) cbar = fig.colorbar(im2, ax=ax[1]) cbar.ax.get_yaxis().labelpad = 15 cbar.ax.set_ylabel('A.U.', rotation=270) ax[1].axis('off') ax[1].set_title('(b) FourierSeries')  error = jnp.abs((pred_fields_fourier[-1] - pred_fields_fd[-1]).on_grid) max_value = jnp.max(pred_fields_fourier[-1].on_grid) error = 100*error/max_value im_error = ax[2].imshow(error, cmap=\"Reds\") cbar = fig.colorbar(im_error, ax=ax[2]) cbar.ax.get_yaxis().labelpad = 15 cbar.ax.set_ylabel('%', rotation=270) ax[2].axis('off') ax[2].set_title('(c) Absolute error (%)')  # Scale bar fontprops = fm.FontProperties(size=12) scalebar = AnchoredSizeBar(     ax[0].transData,     100, '1 cm', 'lower right',      pad=0.3,     color='black',     frameon=False,     size_vertical=2,     fontproperties=fontprops) ax[0].add_artist(scalebar)  fig.tight_layout()  plt.savefig(\"fourier_fd_comparison.pdf\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/ivp/heterogeneous_medium.html","title":"Heterogeneous medium","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n\nfrom jax import jit\nfrom jax import numpy as jnp\nfrom jaxdf import FourierSeries\nfrom matplotlib import pyplot as plt\n\nfrom jwave import FourierSeries\nfrom jwave.acoustics import simulate_wave_propagation\nfrom jwave.geometry import *\nfrom jwave.geometry import circ_mask\nfrom jwave.utils import show_field, show_positive_field\n\ndomain = Domain((128, 128), (0.1e-3, 0.1e-3))\n</pre> import numpy as np  from jax import jit from jax import numpy as jnp from jaxdf import FourierSeries from matplotlib import pyplot as plt  from jwave import FourierSeries from jwave.acoustics import simulate_wave_propagation from jwave.geometry import * from jwave.geometry import circ_mask from jwave.utils import show_field, show_positive_field  domain = Domain((128, 128), (0.1e-3, 0.1e-3)) In\u00a0[2]: Copied! <pre>density = np.ones(domain.N) * 1000\ndensity[50:90, 65:100] = 2300\ndensity = FourierSeries(np.expand_dims(density, -1), domain)\n\nshow_positive_field(density)\n_ = plt.title(\"Density\")\n</pre> density = np.ones(domain.N) * 1000 density[50:90, 65:100] = 2300 density = FourierSeries(np.expand_dims(density, -1), domain)  show_positive_field(density) _ = plt.title(\"Density\") <pre>WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> In\u00a0[3]: Copied! <pre>medium = Medium(domain=domain, sound_speed=1500.0, density=density)\ntime_axis = TimeAxis.from_medium(medium, cfl=0.3)\n</pre> medium = Medium(domain=domain, sound_speed=1500.0, density=density) time_axis = TimeAxis.from_medium(medium, cfl=0.3) In\u00a0[4]: Copied! <pre># Defining the initial pressure\n\nN = domain.N\np0 = circ_mask(N, 3, (64, 30))\n\np0 = 1.0 * jnp.expand_dims(p0, -1)\np0 = FourierSeries(p0, domain)\n</pre> # Defining the initial pressure  N = domain.N p0 = circ_mask(N, 3, (64, 30))  p0 = 1.0 * jnp.expand_dims(p0, -1) p0 = FourierSeries(p0, domain) In\u00a0[5]: Copied! <pre>show_field(p0)\nplt.title(\"Initial pressure\")\n</pre> show_field(p0) plt.title(\"Initial pressure\") Out[5]: <pre>Text(0.5, 1.0, 'Initial pressure')</pre> In\u00a0[6]: Copied! <pre>@jit\ndef compiled_simulator(c, p0):\n    medium = Medium(domain=domain, sound_speed=1500.0, density=c)\n    return simulate_wave_propagation(medium, time_axis, p0=p0)\n</pre> @jit def compiled_simulator(c, p0):     medium = Medium(domain=domain, sound_speed=1500.0, density=c)     return simulate_wave_propagation(medium, time_axis, p0=p0) In\u00a0[7]: Copied! <pre>pressure = compiled_simulator(density, p0)\n</pre> pressure = compiled_simulator(density, p0) In\u00a0[8]: Copied! <pre>t = 270\nshow_field(pressure[t])\nplt.title(f\"Pressure field at t={time_axis.to_array()[t]}\")\n</pre> t = 270 show_field(pressure[t]) plt.title(f\"Pressure field at t={time_axis.to_array()[t]}\") Out[8]: <pre>Text(0.5, 1.0, 'Pressure field at t=5.4000001910026185e-06')</pre> In\u00a0[9]: Copied! <pre>pressure = compiled_simulator(1000.0, p0)  # Works with different input types\n</pre> pressure = compiled_simulator(1000.0, p0)  # Works with different input types In\u00a0[10]: Copied! <pre>t = 270\nshow_field(pressure[t])\nplt.title(f\"Pressure field at t={time_axis.to_array()[t]}\")\n</pre> t = 270 show_field(pressure[t]) plt.title(f\"Pressure field at t={time_axis.to_array()[t]}\") Out[10]: <pre>Text(0.5, 1.0, 'Pressure field at t=5.4000001910026185e-06')</pre> In\u00a0[11]: Copied! <pre>from jaxdf import FiniteDifferences\n\ndensity = np.ones(domain.N) * 1000\ndensity[50:90, 65:100] = 2300\ndensity = FiniteDifferences(np.expand_dims(density, -1), domain, accuracy=8)\n\nN = domain.N\np0 = circ_mask(N, 3, (64, 30))\n\np0 = 1.0 * jnp.expand_dims(p0, -1)\np0 = FiniteDifferences(p0, domain, accuracy=8)\n</pre> from jaxdf import FiniteDifferences  density = np.ones(domain.N) * 1000 density[50:90, 65:100] = 2300 density = FiniteDifferences(np.expand_dims(density, -1), domain, accuracy=8)  N = domain.N p0 = circ_mask(N, 3, (64, 30))  p0 = 1.0 * jnp.expand_dims(p0, -1) p0 = FiniteDifferences(p0, domain, accuracy=8) In\u00a0[12]: Copied! <pre>pressure = compiled_simulator(density, p0)\n</pre> pressure = compiled_simulator(density, p0) In\u00a0[13]: Copied! <pre>t = 270\nshow_field(pressure[t])\nplt.title(f\"Pressure field at t={time_axis.to_array()[t]}\")\n</pre> t = 270 show_field(pressure[t]) plt.title(f\"Pressure field at t={time_axis.to_array()[t]}\") Out[13]: <pre>Text(0.5, 1.0, 'Pressure field at t=5.4000001910026185e-06')</pre>"},{"location":"notebooks/ivp/heterogeneous_medium.html#heterogeneous-medium","title":"Heterogeneous medium\u00b6","text":""},{"location":"notebooks/ivp/homogeneous_medium.html","title":"Homogeneous Medium","text":"In\u00a0[1]: Copied! <pre>from jwave.geometry import Domain\n\nN, dx = (128, 128), (0.1e-3, 0.1e-3)\ndomain = Domain(N, dx)\n</pre> from jwave.geometry import Domain  N, dx = (128, 128), (0.1e-3, 0.1e-3) domain = Domain(N, dx) In\u00a0[2]: Copied! <pre>from jwave.geometry import Medium\n\nmedium = Medium(domain=domain, sound_speed=1500.0)\nprint(medium)\n</pre> from jwave.geometry import Medium  medium = Medium(domain=domain, sound_speed=1500.0) print(medium) <pre>Medium:\n - attenuation: 0.0\n - density: 1.0\n - domain: Domain(N=(128, 128), dx=(0.0001, 0.0001))\n - pml_size: 20\n - sound_speed: 1500.0\n</pre> In\u00a0[3]: Copied! <pre>from jwave.geometry import TimeAxis\n\ntime_axis = TimeAxis.from_medium(medium, cfl=0.3)\n</pre> from jwave.geometry import TimeAxis  time_axis = TimeAxis.from_medium(medium, cfl=0.3) <pre>WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> In\u00a0[4]: Copied! <pre>time_axis\n</pre> time_axis Out[4]: <pre>&lt;jwave.geometry.TimeAxis at 0x7f831ef2d3f0&gt;</pre> In\u00a0[5]: Copied! <pre>from jax import numpy as jnp\n\nfrom jwave import FourierSeries\nfrom jwave.geometry import circ_mask\n\np0 = 1.0 * jnp.expand_dims(circ_mask(N, 4, (80, 60)), -1)\np0 = FourierSeries(p0, domain)\n</pre> from jax import numpy as jnp  from jwave import FourierSeries from jwave.geometry import circ_mask  p0 = 1.0 * jnp.expand_dims(circ_mask(N, 4, (80, 60)), -1) p0 = FourierSeries(p0, domain) In\u00a0[6]: Copied! <pre>from matplotlib import pyplot as plt\n\nfrom jwave.utils import show_field\n\nshow_field(p0)\nplt.title(f\"Initial pressure field\")\nplt.show()\n</pre> from matplotlib import pyplot as plt  from jwave.utils import show_field  show_field(p0) plt.title(f\"Initial pressure field\") plt.show() In\u00a0[7]: Copied! <pre>from jax import jit\n\nfrom jwave.acoustics import simulate_wave_propagation\n\n\n@jit\ndef compiled_simulator(medium, p0):\n    return simulate_wave_propagation(medium, time_axis, p0=p0)\n</pre> from jax import jit  from jwave.acoustics import simulate_wave_propagation   @jit def compiled_simulator(medium, p0):     return simulate_wave_propagation(medium, time_axis, p0=p0) In\u00a0[8]: Copied! <pre>pressure = compiled_simulator(medium, p0)\n</pre> pressure = compiled_simulator(medium, p0) In\u00a0[9]: Copied! <pre>t = 250\nshow_field(pressure[t])\nplt.title(f\"Pressure field at t={time_axis.to_array()[t]}\")\nplt.show()\n</pre> t = 250 show_field(pressure[t]) plt.title(f\"Pressure field at t={time_axis.to_array()[t]}\") plt.show() In\u00a0[10]: Copied! <pre>%timeit compiled_simulator(medium, p0).params.block_until_ready()\n</pre> %timeit compiled_simulator(medium, p0).params.block_until_ready() <pre>478 ms \u00b1 1.3 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre>"},{"location":"notebooks/ivp/homogeneous_medium.html#homogeneous-medium","title":"Homogeneous Medium\u00b6","text":"<p>This example notebook follows the Homogeneous Propagation Medium Example of k-Wave.</p>"},{"location":"notebooks/ivp/homogeneous_medium.html#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/ivp/homogeneous_medium.html#domain","title":"Domain\u00b6","text":"<p>Similarly to k-Wave, j-Wave requires the user to specify a computational domain where the simulation takes place. This is done using the <code>Domain</code> dataclass which is lifted from <code>jaxdf</code>.</p> <p>The inputs for the constructor are the size of the domain in grid points in each spatial direction, and the corresponding discretization steps.</p>"},{"location":"notebooks/ivp/homogeneous_medium.html#acoustic-medium","title":"Acoustic medium\u00b6","text":"<p>In this example, the speed of sound has a constant value of $1500m/s$. The speed of sound is defined as part of the <code>Medium</code> dataclass, which also needs the computational domain as mandatory input argument</p>"},{"location":"notebooks/ivp/homogeneous_medium.html#time","title":"Time\u00b6","text":"<p>Time-stepping simulations requires to define a <code>TimeAxis</code> object, which is used by the timestepping scheme of the numerical simulation. To ensure a stable simulation, this object can be constructed from the <code>medium</code> object for a given CFL number.</p>"},{"location":"notebooks/ivp/homogeneous_medium.html#initial-pressure","title":"Initial pressure\u00b6","text":"<p>The initial pressure distribution is a Field, therefore it must be somehow represented according to a discretization. Most of the functions of <code>jwave</code> are tested using a <code>FourierSeries</code> discretization: since in this example we are not interested in tweaking the underlying discretization, we will use this class to define the initial pressure field.</p>"},{"location":"notebooks/ivp/homogeneous_medium.html#run-the-simulation","title":"Run the simulation\u00b6","text":""},{"location":"notebooks/ivp/homogeneous_medium.html#timings","title":"Timings\u00b6","text":""},{"location":"notebooks/ivp/homogeneous_medium_backprop.html","title":"Automatic differentiation","text":"In\u00a0[1]: Copied! <pre>import matplotlib as mpl\nmpl.rcParams.update({\n    'font.family': 'serif',\n})\n\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\nimport matplotlib.font_manager as fm\n</pre> import matplotlib as mpl mpl.rcParams.update({     'font.family': 'serif', })  from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar import matplotlib.font_manager as fm In\u00a0[2]: Copied! <pre>%run ./homogeneous_medium_sensors.ipynb\n</pre> %run ./homogeneous_medium_sensors.ipynb <pre>Sensors parameters:\n</pre> <p>In this notebooks, we will work on simulated measurements. To make things (a tiny bit) more realistic, we'll add some coloured noise to each sensor trace</p> In\u00a0[3]: Copied! <pre>import numpy as np\nfrom jax import grad, random\n\nfrom jwave.signal_processing import smooth\n\n# Add colored noise\nnoise = random.normal(random.PRNGKey(42), sensors_data.shape)\nfor i in range(noise.shape[1]):\n    noise = noise.at[:, i].set(smooth(noise[:, i]))\n\nnoisy_data = sensors_data + 0.2 * noise\n\n# Show noisy traces\n_field = FourierSeries(noisy_data.T, domain)\nshow_field(_field, \"Noisy acoustic signals\")\nplt.xlabel(\"Time step\")\nplt.ylabel(\"Sensor position\")\nplt.axis(\"on\")\nplt.show()\n</pre> import numpy as np from jax import grad, random  from jwave.signal_processing import smooth  # Add colored noise noise = random.normal(random.PRNGKey(42), sensors_data.shape) for i in range(noise.shape[1]):     noise = noise.at[:, i].set(smooth(noise[:, i]))  noisy_data = sensors_data + 0.2 * noise  # Show noisy traces _field = FourierSeries(noisy_data.T, domain) show_field(_field, \"Noisy acoustic signals\") plt.xlabel(\"Time step\") plt.ylabel(\"Sensor position\") plt.axis(\"on\") plt.show() In\u00a0[4]: Copied! <pre># The following uses the reciprocity of the wave equation to generate\n# a time reversal imaging algorithm\ndef solver(p0):\n    return simulate_wave_propagation(medium, time_axis, p0=p0, sensors=sensors)\n\n\n@jit  # Compile the whole algorithm\ndef lazy_time_reversal(measurements):\n    def mse_loss(p0, measurements):\n        p0 = p0.replace_params(p0.params)\n        p_pred = solver(p0)[..., 0]\n        return 0.5 * jnp.sum(jnp.abs(p_pred - measurements) ** 2)\n\n    # Start from an empty field\n    p0 = FourierSeries.empty(domain)\n\n    # Take the gradient of the MSE loss w.r.t. the\n    # measured data\n    p_grad = grad(mse_loss)(p0, measurements)\n\n    return -p_grad\n\n\n# Reconstruct initial pressure distribution\nrecon_image = lazy_time_reversal(noisy_data)\n\n# Show reconstructed field\nshow_field(recon_image, \"Reconstructed initial pressure using autograd\")\n</pre> # The following uses the reciprocity of the wave equation to generate # a time reversal imaging algorithm def solver(p0):     return simulate_wave_propagation(medium, time_axis, p0=p0, sensors=sensors)   @jit  # Compile the whole algorithm def lazy_time_reversal(measurements):     def mse_loss(p0, measurements):         p0 = p0.replace_params(p0.params)         p_pred = solver(p0)[..., 0]         return 0.5 * jnp.sum(jnp.abs(p_pred - measurements) ** 2)      # Start from an empty field     p0 = FourierSeries.empty(domain)      # Take the gradient of the MSE loss w.r.t. the     # measured data     p_grad = grad(mse_loss)(p0, measurements)      return -p_grad   # Reconstruct initial pressure distribution recon_image = lazy_time_reversal(noisy_data)  # Show reconstructed field show_field(recon_image, \"Reconstructed initial pressure using autograd\") In\u00a0[5]: Copied! <pre># Timings for the reconstruction algorithm, should be\n# ~ 2x the forward function.\n%timeit lazy_time_reversal(noisy_data).params.block_until_ready()\n</pre> # Timings for the reconstruction algorithm, should be # ~ 2x the forward function. %timeit lazy_time_reversal(noisy_data).params.block_until_ready() <pre>393 ms \u00b1 435 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> In\u00a0[8]: Copied! <pre>from scipy.interpolate import interp1d\n\n# Save for paper\nfig, ax = plt.subplots(1,3, figsize=(10,3), dpi=100)\n\nim1 = ax[0].imshow(p0.on_grid, cmap=\"RdBu_r\", vmin=-6, vmax=6)\ncbar = fig.colorbar(im1, ax=ax[0])\ncbar.ax.get_yaxis().labelpad = 5\ncbar.ax.set_ylabel('A.U.', rotation=270)\nax[0].axis('off')\nax[0].set_title('Initial pressure')\nax[0].scatter(x, y, label=\"sensors\", marker='.')\nax[0].legend(loc=\"lower right\")\n\n# Plotting traces\n# adapted from this gist: https://gist.github.com/kwinkunks/f594b243e582666b5a808520e9add262\ndata = np.asarray(noisy_data).T\ntime = np.asarray(time_axis.to_array())\n\nskip=2\nperc=99.0\ngain=1.3\noversampling=100\nrgb=(0, 0, 0)\nalpha=1.0\nlw=0.5\n\nntraces, nt = data.shape\nrgba = list(rgb) + [alpha]\nsc = np.percentile(data, perc)  # Normalization factor\nwigdata = data[::skip]\nxpos = np.arange(ntraces)[::skip]\n\nfor y_trace, trace in zip(xpos, wigdata):\n    amp = gain * trace / sc + y_trace\n    t = 1e6 * time\n    hypertime = np.linspace(t[0], t[-1], (oversampling * t.size - 1) + 1)\n    interp = interp1d(t, amp, kind='cubic')\n    hyperamp = interp(hypertime)\n\n    # Plot the line, then the fill.\n    ax[1].plot(hypertime, hyperamp, 'k', lw=lw)\n    ax[1].fill_between( hypertime, hyperamp, y_trace,\n                     where=hyperamp &gt; y_trace,\n                     facecolor=rgba,\n                     interpolate=True,\n                     lw=0,\n                     )\n\nax[1].yaxis.tick_right()\nax[1].set_title('Noisy traces')\nax[1].set_ylabel(\"Sensor number\")\nax[1].set_xlabel(\"Time $\\mu s$\")\n\nim1 = ax[2].imshow(recon_image.on_grid, cmap=\"RdBu_r\", vmin=-0.3, vmax=0.3)\ncbar = fig.colorbar(im1, ax=ax[2])\ncbar.ax.get_yaxis().labelpad = 5\ncbar.ax.set_ylabel('A.U.', rotation=270)\nax[2].axis('off')\nax[2].set_title('Recovered initial pressure')\n\nfontprops = fm.FontProperties(size=12)\nscalebar = AnchoredSizeBar(\n    ax[2].transData,\n    100, '1 cm', 'lower right', \n    pad=0.3,\n    color='black',\n    frameon=False,\n    size_vertical=2,\n    fontproperties=fontprops)\nax[2].add_artist(scalebar)\n\nfig.tight_layout()\n\nplt.savefig(\"initial_pressure_recon.pdf\")\n</pre> from scipy.interpolate import interp1d  # Save for paper fig, ax = plt.subplots(1,3, figsize=(10,3), dpi=100)  im1 = ax[0].imshow(p0.on_grid, cmap=\"RdBu_r\", vmin=-6, vmax=6) cbar = fig.colorbar(im1, ax=ax[0]) cbar.ax.get_yaxis().labelpad = 5 cbar.ax.set_ylabel('A.U.', rotation=270) ax[0].axis('off') ax[0].set_title('Initial pressure') ax[0].scatter(x, y, label=\"sensors\", marker='.') ax[0].legend(loc=\"lower right\")  # Plotting traces # adapted from this gist: https://gist.github.com/kwinkunks/f594b243e582666b5a808520e9add262 data = np.asarray(noisy_data).T time = np.asarray(time_axis.to_array())  skip=2 perc=99.0 gain=1.3 oversampling=100 rgb=(0, 0, 0) alpha=1.0 lw=0.5  ntraces, nt = data.shape rgba = list(rgb) + [alpha] sc = np.percentile(data, perc)  # Normalization factor wigdata = data[::skip] xpos = np.arange(ntraces)[::skip]  for y_trace, trace in zip(xpos, wigdata):     amp = gain * trace / sc + y_trace     t = 1e6 * time     hypertime = np.linspace(t[0], t[-1], (oversampling * t.size - 1) + 1)     interp = interp1d(t, amp, kind='cubic')     hyperamp = interp(hypertime)      # Plot the line, then the fill.     ax[1].plot(hypertime, hyperamp, 'k', lw=lw)     ax[1].fill_between( hypertime, hyperamp, y_trace,                      where=hyperamp &gt; y_trace,                      facecolor=rgba,                      interpolate=True,                      lw=0,                      )  ax[1].yaxis.tick_right() ax[1].set_title('Noisy traces') ax[1].set_ylabel(\"Sensor number\") ax[1].set_xlabel(\"Time $\\mu s$\")  im1 = ax[2].imshow(recon_image.on_grid, cmap=\"RdBu_r\", vmin=-0.3, vmax=0.3) cbar = fig.colorbar(im1, ax=ax[2]) cbar.ax.get_yaxis().labelpad = 5 cbar.ax.set_ylabel('A.U.', rotation=270) ax[2].axis('off') ax[2].set_title('Recovered initial pressure')  fontprops = fm.FontProperties(size=12) scalebar = AnchoredSizeBar(     ax[2].transData,     100, '1 cm', 'lower right',      pad=0.3,     color='black',     frameon=False,     size_vertical=2,     fontproperties=fontprops) ax[2].add_artist(scalebar)  fig.tight_layout()  plt.savefig(\"initial_pressure_recon.pdf\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/ivp/homogeneous_medium_backprop.html#automatic-differentiation","title":"Automatic differentiation\u00b6","text":"<p>In <code>jwave</code>, it is possible to take the gradient with respect to any scalar loss, as shown in the following example. The gradients will have the same datatypes as the inputs of to the function, so <code>Field</code> gradients will be mapped to <code>Field</code> objects.</p> <p>Here, we write a simple time reversal algorithm using autodiff. Note that time-reversal is proportional to the derivative operator of the <code>MSE</code> loss with respect to the measurement data, applied with zero initial conditions.</p>"},{"location":"notebooks/ivp/homogeneous_medium_sensors.html","title":"Sensors","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom jax import jit\nfrom jax import numpy as jnp\nfrom matplotlib import pyplot as plt\n\nfrom jwave import FourierSeries\nfrom jwave.acoustics import simulate_wave_propagation\nfrom jwave.geometry import *\nfrom jwave.geometry import Sensors, circ_mask, points_on_circle\nfrom jwave.utils import show_field\n\ndomain = Domain((256, 256), (0.1e-3, 0.1e-3))\nmedium = Medium(domain=domain, sound_speed=1500.0)\ntime_axis = TimeAxis.from_medium(medium, cfl=0.3)\n</pre> import numpy as np from jax import jit from jax import numpy as jnp from matplotlib import pyplot as plt  from jwave import FourierSeries from jwave.acoustics import simulate_wave_propagation from jwave.geometry import * from jwave.geometry import Sensors, circ_mask, points_on_circle from jwave.utils import show_field  domain = Domain((256, 256), (0.1e-3, 0.1e-3)) medium = Medium(domain=domain, sound_speed=1500.0) time_axis = TimeAxis.from_medium(medium, cfl=0.3) <pre>No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> In\u00a0[2]: Copied! <pre># Defining the initial pressure\n\nN = domain.N\nmask1 = circ_mask(N, 16, (100, 100))\nmask2 = circ_mask(N, 10, (160, 120))\nmask3 = circ_mask(N, 20, (128, 128))\nmask4 = circ_mask(N, 60, (128, 128))\np0 = 5.0 * mask1 + 3.0 * mask2 + 4.0 * mask3 + 0.5 * mask4\n\np0 = 1.0 * jnp.expand_dims(p0, -1)\np0 = FourierSeries(p0, domain)\n</pre> # Defining the initial pressure  N = domain.N mask1 = circ_mask(N, 16, (100, 100)) mask2 = circ_mask(N, 10, (160, 120)) mask3 = circ_mask(N, 20, (128, 128)) mask4 = circ_mask(N, 60, (128, 128)) p0 = 5.0 * mask1 + 3.0 * mask2 + 4.0 * mask3 + 0.5 * mask4  p0 = 1.0 * jnp.expand_dims(p0, -1) p0 = FourierSeries(p0, domain) In\u00a0[3]: Copied! <pre>show_field(p0)\nplt.title(\"Initial pressure\")\n</pre> show_field(p0) plt.title(\"Initial pressure\") Out[3]: <pre>Text(0.5, 1.0, 'Initial pressure')</pre> In\u00a0[4]: Copied! <pre>num_sensors = 48\nx, y = points_on_circle(num_sensors, 100, (128, 128))\nsensors_positions = (x, y)\nsensors = Sensors(positions=sensors_positions)\n\nprint(\"Sensors parameters:\")\nSensors.__annotations__\n</pre> num_sensors = 48 x, y = points_on_circle(num_sensors, 100, (128, 128)) sensors_positions = (x, y) sensors = Sensors(positions=sensors_positions)  print(\"Sensors parameters:\") Sensors.__annotations__ <pre>Sensors parameters:\n</pre> Out[4]: <pre>{'positions': typing.Tuple[tuple]}</pre> In\u00a0[5]: Copied! <pre>@jit\ndef compiled_simulator(medium, p0):\n    a = simulate_wave_propagation(medium, time_axis, p0=p0, sensors=sensors)\n    return a\n</pre> @jit def compiled_simulator(medium, p0):     a = simulate_wave_propagation(medium, time_axis, p0=p0, sensors=sensors)     return a In\u00a0[6]: Copied! <pre>sensors_data = compiled_simulator(medium, p0)[..., 0]\n</pre> sensors_data = compiled_simulator(medium, p0)[..., 0] In\u00a0[7]: Copied! <pre>_field = FourierSeries(sensors_data.T, domain)\nshow_field(_field, \"Recorded acoustic signals\")\nplt.xlabel(\"Time step\")\nplt.ylabel(\"Sensor position\")\nplt.axis(\"on\")\nplt.show()\n</pre> _field = FourierSeries(sensors_data.T, domain) show_field(_field, \"Recorded acoustic signals\") plt.xlabel(\"Time step\") plt.ylabel(\"Sensor position\") plt.axis(\"on\") plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/ivp/homogeneous_medium_sensors.html#sensors","title":"Sensors\u00b6","text":""},{"location":"notebooks/ivp/off_grid_sensors.html","title":"Off-grid sensors","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom jax import jit, grad\nfrom jax import numpy as jnp\nfrom matplotlib import pyplot as plt\n\nfrom jwave import FourierSeries\nfrom jwave.acoustics import simulate_wave_propagation\nfrom jwave.geometry import Sensors, circ_mask, BLISensors, Domain, Medium, TimeAxis\nfrom jwave.utils import show_field\n\nfrom functools import partial\n</pre> import numpy as np from jax import jit, grad from jax import numpy as jnp from matplotlib import pyplot as plt  from jwave import FourierSeries from jwave.acoustics import simulate_wave_propagation from jwave.geometry import Sensors, circ_mask, BLISensors, Domain, Medium, TimeAxis from jwave.utils import show_field  from functools import partial <p>The first section is identical to previous examples. Ee define the simulation domain, the medium in which the wave will propagate and the time axis.</p> In\u00a0[2]: Copied! <pre>Nx = 128\ndx = 0.2e-3\n\ndomain = Domain((Nx, Nx), (dx, dx))\nmedium = Medium(domain=domain, sound_speed=1500.0)\ntime_axis = TimeAxis.from_medium(medium, cfl=0.3)\n</pre> Nx = 128 dx = 0.2e-3  domain = Domain((Nx, Nx), (dx, dx)) medium = Medium(domain=domain, sound_speed=1500.0) time_axis = TimeAxis.from_medium(medium, cfl=0.3) <pre>No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> <p>Next, we define the initial pressure distribution, which in our case is a series of circles.</p> In\u00a0[3]: Copied! <pre># Defining the initial pressure\nN = domain.N\nmask1 = circ_mask(N, 16 * Nx / 256, (100 * Nx / 256, 100 * Nx / 256))\nmask2 = circ_mask(N, 10 * Nx / 256, (160 * Nx / 256, 120 * Nx / 256))\nmask3 = circ_mask(N, 20 * Nx / 256, (128 * Nx / 256, 128 * Nx / 256))\nmask4 = circ_mask(N, 60 * Nx / 256, (128 * Nx / 256, 128 * Nx / 256))\np0 = 5.0 * mask1 + 3.0 * mask2 + 4.0 * mask3 + 0.5 * mask4\n\np0 = 1.0 * jnp.expand_dims(p0, -1)\np0 = FourierSeries(p0, domain)\n\nshow_field(p0)\nplt.title(\"Initial pressure\")\nplt.show()\n</pre> # Defining the initial pressure N = domain.N mask1 = circ_mask(N, 16 * Nx / 256, (100 * Nx / 256, 100 * Nx / 256)) mask2 = circ_mask(N, 10 * Nx / 256, (160 * Nx / 256, 120 * Nx / 256)) mask3 = circ_mask(N, 20 * Nx / 256, (128 * Nx / 256, 128 * Nx / 256)) mask4 = circ_mask(N, 60 * Nx / 256, (128 * Nx / 256, 128 * Nx / 256)) p0 = 5.0 * mask1 + 3.0 * mask2 + 4.0 * mask3 + 0.5 * mask4  p0 = 1.0 * jnp.expand_dims(p0, -1) p0 = FourierSeries(p0, domain)  show_field(p0) plt.title(\"Initial pressure\") plt.show() <p>Next, we define a series of sensors on a circle. We will compare the on-grid and off-grid sensor implementations so both are defined here.</p> In\u00a0[4]: Copied! <pre>num_sensors = 256\nsensor_radius = 100 * Nx / 256\n\ntheta = np.linspace(0, 2 * np.pi, num_sensors, endpoint=False)\nx = np.cos(theta) * sensor_radius + Nx / 2\ny = np.sin(theta) * sensor_radius + Nx / 2\n\nsensors_on_grid = Sensors(positions=(x.astype(int), y.astype(int)))\nsensors_off_grid = BLISensors(positions=(x, y), n=domain.N)\n</pre> num_sensors = 256 sensor_radius = 100 * Nx / 256  theta = np.linspace(0, 2 * np.pi, num_sensors, endpoint=False) x = np.cos(theta) * sensor_radius + Nx / 2 y = np.sin(theta) * sensor_radius + Nx / 2  sensors_on_grid = Sensors(positions=(x.astype(int), y.astype(int))) sensors_off_grid = BLISensors(positions=(x, y), n=domain.N) <p>We make a simulator that records both the on-grid measurements and the off-grid measurements, and compile it using the jit function.</p> In\u00a0[5]: Copied! <pre>def multi_sensors(*args):\n    return {\"On Grid\": sensors_on_grid(*args), \"Off Grid\": sensors_off_grid(*args)}\n\ndef compiled_simulator(medium, p0, sensors):\n    a = simulate_wave_propagation(medium, time_axis, p0=p0, sensors=sensors)\n    return a\n\ncompiled_simulator_multi_sensors = jit(partial(compiled_simulator, sensors=multi_sensors))\n</pre> def multi_sensors(*args):     return {\"On Grid\": sensors_on_grid(*args), \"Off Grid\": sensors_off_grid(*args)}  def compiled_simulator(medium, p0, sensors):     a = simulate_wave_propagation(medium, time_axis, p0=p0, sensors=sensors)     return a  compiled_simulator_multi_sensors = jit(partial(compiled_simulator, sensors=multi_sensors)) <p>Now we run the simulation and extract the sensor data from the off-grid sensors and the on-grid sensors.</p> In\u00a0[6]: Copied! <pre>sensors_data = compiled_simulator_multi_sensors(medium, p0)\noff_grid_sensor_data = sensors_data[\"Off Grid\"]\non_grid_sensor_data = sensors_data[\"On Grid\"]\n</pre> sensors_data = compiled_simulator_multi_sensors(medium, p0) off_grid_sensor_data = sensors_data[\"Off Grid\"] on_grid_sensor_data = sensors_data[\"On Grid\"] <p>To compare the two sensor types, we plot their time series.</p> In\u00a0[7]: Copied! <pre>fig, (ax2, ax1) = plt.subplots(2, 1, sharex=True)\n\nim = ax1.imshow(off_grid_sensor_data.T[0], aspect=\"auto\", interpolation=\"none\", cmap=\"RdBu_r\")\nax2.imshow(on_grid_sensor_data.T[0], aspect=\"auto\", interpolation=\"none\", clim=im.get_clim(), cmap=\"RdBu_r\")\n\nax1.set_title(\"Band Limited Interpolation (Off-Grid)\")\n\nax1.set_xlabel(\"Time step\")\nax1.set_ylabel(\"Detector\")\nax2.set_ylabel(\"Detector\")\n\nax2.set_title(\"On-Grid Sensors\")\nplt.tight_layout()\nplt.colorbar(im, ax=[ax1, ax2])\nplt.show()\n</pre> fig, (ax2, ax1) = plt.subplots(2, 1, sharex=True)  im = ax1.imshow(off_grid_sensor_data.T[0], aspect=\"auto\", interpolation=\"none\", cmap=\"RdBu_r\") ax2.imshow(on_grid_sensor_data.T[0], aspect=\"auto\", interpolation=\"none\", clim=im.get_clim(), cmap=\"RdBu_r\")  ax1.set_title(\"Band Limited Interpolation (Off-Grid)\")  ax1.set_xlabel(\"Time step\") ax1.set_ylabel(\"Detector\") ax2.set_ylabel(\"Detector\")  ax2.set_title(\"On-Grid Sensors\") plt.tight_layout() plt.colorbar(im, ax=[ax1, ax2]) plt.show() In\u00a0[8]: Copied! <pre>@jit\ndef get_sensor_loss(sensor_radius):\n    num_sensors = 256\n    theta = jnp.linspace(0, 2 * np.pi, num_sensors, endpoint=False)\n    x = jnp.cos(theta) * sensor_radius + Nx / 2\n    y = jnp.sin(theta) * sensor_radius + Nx / 2\n    \n    s = BLISensors(positions=(x, y), n=domain.N)\n    result_with_sensors = jit(compiled_simulator)(medium, p0, s)\n    \n    return jnp.mean((on_grid_sensor_data - result_with_sensors)**2)\n</pre> @jit def get_sensor_loss(sensor_radius):     num_sensors = 256     theta = jnp.linspace(0, 2 * np.pi, num_sensors, endpoint=False)     x = jnp.cos(theta) * sensor_radius + Nx / 2     y = jnp.sin(theta) * sensor_radius + Nx / 2          s = BLISensors(positions=(x, y), n=domain.N)     result_with_sensors = jit(compiled_simulator)(medium, p0, s)          return jnp.mean((on_grid_sensor_data - result_with_sensors)**2) <p>We then do a basic gradient descent, updating the radius by a small step every time, converging on the true value, 50.</p> In\u00a0[10]: Copied! <pre>dlossdr = grad(get_sensor_loss)\n\nr = 40.\nstep_size = 100\nn_steps = 10\ngradient = np.nan\n\nfor i in range(n_steps):\n    loss = get_sensor_loss(r)\n    print(f\"Step {i}. Guess: R = {r:.1f}, Loss = {loss:.3f}, Gradient = {gradient:.3f}\")\n    gradient = dlossdr(r)\n    \n    r = r - gradient * step_size\n\nloss = get_sensor_loss(r)\nprint(f\"End: Guess: R = {r:.1f}, Loss = {loss:.3f}\")\n</pre> dlossdr = grad(get_sensor_loss)  r = 40. step_size = 100 n_steps = 10 gradient = np.nan  for i in range(n_steps):     loss = get_sensor_loss(r)     print(f\"Step {i}. Guess: R = {r:.1f}, Loss = {loss:.3f}, Gradient = {gradient:.3f}\")     gradient = dlossdr(r)          r = r - gradient * step_size  loss = get_sensor_loss(r) print(f\"End: Guess: R = {r:.1f}, Loss = {loss:.3f}\") <pre>Step 0. Guess: R = 40.0, Loss = 0.170, Gradient = nan\nStep 1. Guess: R = 41.6, Loss = 0.144, Gradient = -0.016\nStep 2. Guess: R = 43.3, Loss = 0.114, Gradient = -0.017\nStep 3. Guess: R = 45.1, Loss = 0.079, Gradient = -0.018\nStep 4. Guess: R = 47.1, Loss = 0.040, Gradient = -0.020\nStep 5. Guess: R = 49.1, Loss = 0.007, Gradient = -0.020\nStep 6. Guess: R = 50.1, Loss = 0.002, Gradient = -0.010\nStep 7. Guess: R = 49.9, Loss = 0.002, Gradient = 0.001\nStep 8. Guess: R = 50.0, Loss = 0.002, Gradient = -0.000\nStep 9. Guess: R = 50.0, Loss = 0.002, Gradient = 0.000\nEnd: Guess: R = 50.0, Loss = 0.002\n</pre>"},{"location":"notebooks/ivp/off_grid_sensors.html#off-grid-sensors","title":"Off-grid sensors\u00b6","text":"<p>This example demonstrates how to use the band-limited interpolant implementation of sensors in jWave. This removes the staircasing effects that are observed when sensors are defined as binary masks.</p>"},{"location":"notebooks/ivp/off_grid_sensors.html#gradient-descent-on-sensor-positions","title":"Gradient descent on sensor positions.\u00b6","text":"<p>The beauty of the JAX implementation of j-Wave and the band limited interpolation is that it allows you to differentiate with respect to any parameter, including sensor position.</p> <p>To illustrate that feature, we will use gradient descent to calculate the radius of the detectors.</p> <p>First, we will define a loss function, for this we will use the mean square error. We differentiate that using the jax grad function and iteratively adjust the radius guess until it is close to the value defined above, 50.</p>"},{"location":"notebooks/others/save_video.html","title":"Save video","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom jax import jit\nfrom jax import numpy as jnp\n\nfrom jwave import FourierSeries\nfrom jwave.geometry import Domain, Medium, TimeAxis\nfrom jwave.acoustics import simulate_wave_propagation\nfrom jwave.geometry import circ_mask\n\ndomain = Domain((128, 128), (0.1e-3, 0.1e-3))\n</pre> import numpy as np from jax import jit from jax import numpy as jnp  from jwave import FourierSeries from jwave.geometry import Domain, Medium, TimeAxis from jwave.acoustics import simulate_wave_propagation from jwave.geometry import circ_mask  domain = Domain((128, 128), (0.1e-3, 0.1e-3)) In\u00a0[2]: Copied! <pre># Defining an heterogeneous density map\ndensity = np.ones(domain.N) * 1000\ndensity[50:90, 65:100] = 2300\ndensity = FourierSeries(np.expand_dims(density, -1), domain)\n\nmedium = Medium(domain=domain, sound_speed=1500.0, density=density)\ntime_axis = TimeAxis.from_medium(medium, cfl=0.3)\n\n# Defining the initial pressure\nN = domain.N\np0 = circ_mask(N, 3, (64, 30))\np0 = 1.0 * jnp.expand_dims(p0, -1)\np0 = FourierSeries(p0, domain)\n</pre> # Defining an heterogeneous density map density = np.ones(domain.N) * 1000 density[50:90, 65:100] = 2300 density = FourierSeries(np.expand_dims(density, -1), domain)  medium = Medium(domain=domain, sound_speed=1500.0, density=density) time_axis = TimeAxis.from_medium(medium, cfl=0.3)  # Defining the initial pressure N = domain.N p0 = circ_mask(N, 3, (64, 30)) p0 = 1.0 * jnp.expand_dims(p0, -1) p0 = FourierSeries(p0, domain) <pre>No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> In\u00a0[3]: Copied! <pre>medium = Medium(domain=domain, sound_speed=1500.0, density=density)\npressure = simulate_wave_propagation(medium, time_axis, p0=p0)\n</pre> medium = Medium(domain=domain, sound_speed=1500.0, density=density) pressure = simulate_wave_propagation(medium, time_axis, p0=p0) In\u00a0[4]: Copied! <pre>from jwave.extras.export import save_video\n\nsave_video(pressure, './sample_video.mp4', vmax=0.05, vmin=-0.05, fps=50)\n</pre> from jwave.extras.export import save_video  save_video(pressure, './sample_video.mp4', vmax=0.05, vmin=-0.05, fps=50) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 599/599 [00:01&lt;00:00, 347.57it/s]\n</pre> <p>You can now find a video in the same folder as this notebook</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/others/save_video.html#save-video","title":"Save video\u00b6","text":"<p>\u26a0\ufe0f The <code>save_video</code> funcion requires <code>opencv</code> and (optionally) <code>tqdm</code>, which are not installed by default.</p>"},{"location":"notebooks/time_varying/FWI.html","title":"Full Wave Inversion","text":"<p>\u26a0\ufe0f Run the next cell cell if you don't have <code>tqdm</code> installed</p> In\u00a0[2]: Copied! <pre>!pip install tqdm\n</pre> !pip install tqdm <pre>Requirement already satisfied: tqdm in /home/astanziola/repos/jwave/.venv/lib/python3.9/site-packages (4.64.1)\n</pre> In\u00a0[1]: Copied! <pre>from functools import partial\n\nimport numpy as np\nfrom jax import grad, jit, lax, nn\nfrom jax import numpy as jnp\nfrom jax import random, value_and_grad, vmap\nfrom jax.example_libraries import optimizers\nfrom matplotlib import pyplot as plt\nfrom tqdm import tqdm\n\nfrom jwave import FourierSeries\nfrom jwave.acoustics import simulate_wave_propagation\nfrom jwave.geometry import (\n    Domain,\n    Medium,\n    Sensors,\n    Sources,\n    TimeAxis,\n    circ_mask,\n    points_on_circle,\n)\nfrom jwave.signal_processing import apply_ramp, gaussian_window, smooth\n</pre> from functools import partial  import numpy as np from jax import grad, jit, lax, nn from jax import numpy as jnp from jax import random, value_and_grad, vmap from jax.example_libraries import optimizers from matplotlib import pyplot as plt from tqdm import tqdm  from jwave import FourierSeries from jwave.acoustics import simulate_wave_propagation from jwave.geometry import (     Domain,     Medium,     Sensors,     Sources,     TimeAxis,     circ_mask,     points_on_circle, ) from jwave.signal_processing import apply_ramp, gaussian_window, smooth <p>The first step is to define the simulation settings, from the geometrical properties of the domain to the sources and receivers.</p> In\u00a0[2]: Copied! <pre># Settings\nN = (256, 256)\ndx = (0.1e-3, 0.1e-3)\ncfl = 0.25\nnum_sources = 64\nsource_freq = 1e6\nsource_mag = 1.3e-5\nrandom_seed = random.PRNGKey(42)\n\n# Define domain\ndomain = Domain(N, dx)\n\n# Define medium\nsound_speed = jnp.ones(N)\ncircle_1 = circ_mask(N, 16, (100, 100))\ncircle_2 = circ_mask(N, 20, (165, 128))\ncircle_3 = circ_mask(N, 40, (130, 130))\nsound_speed = sound_speed + 0.05 * circle_1 + 0.02 * circle_2 + 0.03 * circle_3\nsound_speed = sound_speed * 1480\nsound_speed = FourierSeries(jnp.expand_dims(sound_speed, -1), domain)\n\nmedium = Medium(domain=domain, sound_speed=sound_speed, pml_size=20.0)\n\n# Time axis\ntime_axis = TimeAxis.from_medium(medium, cfl=cfl)\n\n# Sources\nsource_mag = source_mag / time_axis.dt\nt = time_axis.to_array()\ns1 = source_mag * jnp.sin(2 * jnp.pi * source_freq * t)\nsignal = gaussian_window(apply_ramp(s1, time_axis.dt, source_freq), t, 3e-6, 1.2e-6)\nx, y = points_on_circle(num_sources, 100, (128, 128))\nsource_positions = (jnp.array(x), jnp.array(y))\n\n# Sensors\nsensors_positions = (x, y)\nsensors = Sensors(positions=sensors_positions)\n</pre> # Settings N = (256, 256) dx = (0.1e-3, 0.1e-3) cfl = 0.25 num_sources = 64 source_freq = 1e6 source_mag = 1.3e-5 random_seed = random.PRNGKey(42)  # Define domain domain = Domain(N, dx)  # Define medium sound_speed = jnp.ones(N) circle_1 = circ_mask(N, 16, (100, 100)) circle_2 = circ_mask(N, 20, (165, 128)) circle_3 = circ_mask(N, 40, (130, 130)) sound_speed = sound_speed + 0.05 * circle_1 + 0.02 * circle_2 + 0.03 * circle_3 sound_speed = sound_speed * 1480 sound_speed = FourierSeries(jnp.expand_dims(sound_speed, -1), domain)  medium = Medium(domain=domain, sound_speed=sound_speed, pml_size=20.0)  # Time axis time_axis = TimeAxis.from_medium(medium, cfl=cfl)  # Sources source_mag = source_mag / time_axis.dt t = time_axis.to_array() s1 = source_mag * jnp.sin(2 * jnp.pi * source_freq * t) signal = gaussian_window(apply_ramp(s1, time_axis.dt, source_freq), t, 3e-6, 1.2e-6) x, y = points_on_circle(num_sources, 100, (128, 128)) source_positions = (jnp.array(x), jnp.array(y))  # Sensors sensors_positions = (x, y) sensors = Sensors(positions=sensors_positions) <pre>No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n</pre> <p>Let's visualize the simulation settings to get a better understanding of the setup:</p> In\u00a0[3]: Copied! <pre># Show simulation setup\nfig, ax = plt.subplots(1, 2, figsize=(15, 4), gridspec_kw={\"width_ratios\": [1, 2]})\n\nax[0].imshow(medium.sound_speed.on_grid, cmap=\"gray\")\nax[0].scatter(\n    source_positions[1], source_positions[0], c=\"r\", marker=\"x\", label=\"sources\"\n)\nax[0].scatter(\n    sensors_positions[1], sensors_positions[0], c=\"g\", marker=\".\", label=\"sensors\"\n)\nax[0].legend(loc=\"lower right\")\nax[0].set_title(\"Sound speed\")\nax[0].axis(\"off\")\n\nax[1].plot(signal, label=\"Source 1\", c=\"k\")\nax[1].set_title(\"Source signals\")\n#ax[1].get_yaxis().set_visible(False)\n</pre> # Show simulation setup fig, ax = plt.subplots(1, 2, figsize=(15, 4), gridspec_kw={\"width_ratios\": [1, 2]})  ax[0].imshow(medium.sound_speed.on_grid, cmap=\"gray\") ax[0].scatter(     source_positions[1], source_positions[0], c=\"r\", marker=\"x\", label=\"sources\" ) ax[0].scatter(     sensors_positions[1], sensors_positions[0], c=\"g\", marker=\".\", label=\"sensors\" ) ax[0].legend(loc=\"lower right\") ax[0].set_title(\"Sound speed\") ax[0].axis(\"off\")  ax[1].plot(signal, label=\"Source 1\", c=\"k\") ax[1].set_title(\"Source signals\") #ax[1].get_yaxis().set_visible(False) Out[3]: <pre>Text(0.5, 1.0, 'Source signals')</pre> In\u00a0[4]: Copied! <pre>plt.imshow(medium.sound_speed.on_grid)\nplt.colorbar()\n</pre> plt.imshow(medium.sound_speed.on_grid) plt.colorbar() Out[4]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x7f08c4776110&gt;</pre> In\u00a0[5]: Copied! <pre>src_signal = jnp.stack([signal])\n\n# We can compile the entire function! All the constructors\n# that don't depend on the inputs will be statically compiled\n# and run only once.\n@jit\ndef single_source_simulation(sound_speed, source_num):\n    # Setting source\n    x = lax.dynamic_slice(source_positions[0], (source_num,), (1,))\n    y = lax.dynamic_slice(source_positions[1], (source_num,), (1,))\n    sources = Sources((x, y), src_signal, dt=time_axis.dt, domain=domain)\n\n    # Updating medium with the input speed of sound map\n    medium = Medium(domain=domain, sound_speed=sound_speed, pml_size=20)\n\n    # Run simulations\n    rf_signals = simulate_wave_propagation(\n        medium, time_axis, sources=sources, sensors=sensors, checkpoint=True\n    )\n    return rf_signals[..., 0]\n</pre> src_signal = jnp.stack([signal])  # We can compile the entire function! All the constructors # that don't depend on the inputs will be statically compiled # and run only once. @jit def single_source_simulation(sound_speed, source_num):     # Setting source     x = lax.dynamic_slice(source_positions[0], (source_num,), (1,))     y = lax.dynamic_slice(source_positions[1], (source_num,), (1,))     sources = Sources((x, y), src_signal, dt=time_axis.dt, domain=domain)      # Updating medium with the input speed of sound map     medium = Medium(domain=domain, sound_speed=sound_speed, pml_size=20)      # Run simulations     rf_signals = simulate_wave_propagation(         medium, time_axis, sources=sources, sensors=sensors, checkpoint=True     )     return rf_signals[..., 0] In\u00a0[6]: Copied! <pre>p = single_source_simulation(medium.sound_speed, 20)\n\n# Visualize the acoustic traces\nplt.figure(figsize=(6, 4.5))\nmaxval = jnp.amax(jnp.abs(p))\nplt.imshow(\n    p, cmap=\"RdBu_r\", vmin=-1, vmax=1, interpolation=\"nearest\", aspect=\"auto\"\n)\nplt.colorbar()\nplt.title(\"Acoustic traces\")\nplt.xlabel(\"Sensor index\")\nplt.ylabel(\"Time\")\nplt.show()\n</pre> p = single_source_simulation(medium.sound_speed, 20)  # Visualize the acoustic traces plt.figure(figsize=(6, 4.5)) maxval = jnp.amax(jnp.abs(p)) plt.imshow(     p, cmap=\"RdBu_r\", vmin=-1, vmax=1, interpolation=\"nearest\", aspect=\"auto\" ) plt.colorbar() plt.title(\"Acoustic traces\") plt.xlabel(\"Sensor index\") plt.ylabel(\"Time\") plt.show() In\u00a0[9]: Copied! <pre>%%timeit\nsingle_source_simulation(medium.sound_speed, 1).block_until_ready()\n</pre> %%timeit single_source_simulation(medium.sound_speed, 1).block_until_ready() <pre>268 ms \u00b1 195 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> <p>Because we can apply arbitrary function transformations on the simulation code, we can use <code>vmap</code> to efficiently parallelize the simulation for all sources. We'll use it as a fast method to generate all the snapshots used as data.</p> In\u00a0[10]: Copied! <pre>batch_simulations = vmap(single_source_simulation, in_axes=(None, 0))\np_data = batch_simulations(medium.sound_speed, jnp.arange(num_sources))\nprint(f\"Size of data [Source idx, Time, Sensor idx]: {p_data.shape}\")\n</pre> batch_simulations = vmap(single_source_simulation, in_axes=(None, 0)) p_data = batch_simulations(medium.sound_speed, jnp.arange(num_sources)) print(f\"Size of data [Source idx, Time, Sensor idx]: {p_data.shape}\") <pre>Size of data [Source idx, Time, Sensor idx]: (64, 1558, 64)\n</pre> <p>Note that the execution time is smaller than 32$\\times$ the single source simulation runtime</p> In\u00a0[54]: Copied! <pre>%%timeit\nbatch_simulations(medium.sound_speed, jnp.arange(num_sources)).block_until_ready()\n</pre> %%timeit batch_simulations(medium.sound_speed, jnp.arange(num_sources)).block_until_ready() <pre>6.57 s \u00b1 1.16 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</pre> <p>At last, let's add some coloured noise to the data that we'll use for inversion.</p> In\u00a0[11]: Copied! <pre>p_data = batch_simulations(medium.sound_speed, jnp.arange(num_sources))\nnoise = np.random.normal(size=p_data.shape) * 0.2\nnoise = jnp.fft.fft(noise, axis=1)\n#noise = noise.at[:, 100:-100].set(0.0)\nnoise = jnp.fft.ifft(noise, axis=1).real\np_data = p_data + noise\n\nplt.plot(p_data[12, :, 0])\nplt.title(\"Example of noisy traces\")\nplt.show()\n</pre> p_data = batch_simulations(medium.sound_speed, jnp.arange(num_sources)) noise = np.random.normal(size=p_data.shape) * 0.2 noise = jnp.fft.fft(noise, axis=1) #noise = noise.at[:, 100:-100].set(0.0) noise = jnp.fft.ifft(noise, axis=1).real p_data = p_data + noise  plt.plot(p_data[12, :, 0]) plt.title(\"Example of noisy traces\") plt.show() In\u00a0[12]: Copied! <pre>from jaxdf.operators import compose\n\nmask = circ_mask(domain.N, 80, (128, 128))\nmask = FourierSeries(jnp.expand_dims(mask, -1), domain)\n\ndef get_sound_speed(params):\n    return 1480.0 + 150.0*compose(params)(nn.sigmoid) * mask\n\nparams = medium.sound_speed * 0.0 - 4\n</pre> from jaxdf.operators import compose  mask = circ_mask(domain.N, 80, (128, 128)) mask = FourierSeries(jnp.expand_dims(mask, -1), domain)  def get_sound_speed(params):     return 1480.0 + 150.0*compose(params)(nn.sigmoid) * mask  params = medium.sound_speed * 0.0 - 4 <p>Lastly, let's define the loss function. We'll use the standard MSE loss on the residual. We then use the decorator <code>value_and_grad</code> to transform the function into one that returns the original output and the gradient with respect to the first input</p> In\u00a0[13]: Copied! <pre>from jwave.signal_processing import analytic_signal\nfrom jaxdf.operators import gradient, functional\n\ndef hilbert_transf(signal, noise=0.2):\n    x = jnp.abs(analytic_signal(signal))\n    return x\n\ndef loss_func(params, source_num):\n    c0 = get_sound_speed(params)\n    p = single_source_simulation(c0, source_num)\n    data = p_data[source_num]\n    return jnp.mean(jnp.abs(hilbert_transf(p) -hilbert_transf(data)) ** 2)\n\nloss_with_grad = value_and_grad(loss_func, argnums=0)\n</pre> from jwave.signal_processing import analytic_signal from jaxdf.operators import gradient, functional  def hilbert_transf(signal, noise=0.2):     x = jnp.abs(analytic_signal(signal))     return x  def loss_func(params, source_num):     c0 = get_sound_speed(params)     p = single_source_simulation(c0, source_num)     data = p_data[source_num]     return jnp.mean(jnp.abs(hilbert_transf(p) -hilbert_transf(data)) ** 2)  loss_with_grad = value_and_grad(loss_func, argnums=0) <p>Let's visualize an example of the speed of sound gradient for a given source</p> In\u00a0[14]: Copied! <pre>plt.plot(hilbert_transf(p_data[12, :, 0]))\nplt.plot(p_data[12, :, 0])\nplt.show()\n</pre> plt.plot(hilbert_transf(p_data[12, :, 0])) plt.plot(p_data[12, :, 0]) plt.show() In\u00a0[15]: Copied! <pre>def smooth_fun(gradient):\n    x = gradient.on_grid[..., 0]\n    for _ in range(3):\n        x = smooth(x)\n    return gradient.replace_params(jnp.expand_dims(x, -1))*6\n\nloss, gradient = loss_with_grad(params, source_num=10)\ngradient = smooth_fun(gradient)\n\n# Viualize\nplt.figure(figsize=(8, 6))\nplt.imshow(gradient.on_grid, cmap=\"RdBu_r\", vmin=-0.0003, vmax=0.0003)\nplt.title(\"Smoothed gradient\")\nplt.colorbar()\nplt.show()\n</pre> def smooth_fun(gradient):     x = gradient.on_grid[..., 0]     for _ in range(3):         x = smooth(x)     return gradient.replace_params(jnp.expand_dims(x, -1))*6  loss, gradient = loss_with_grad(params, source_num=10) gradient = smooth_fun(gradient)  # Viualize plt.figure(figsize=(8, 6)) plt.imshow(gradient.on_grid, cmap=\"RdBu_r\", vmin=-0.0003, vmax=0.0003) plt.title(\"Smoothed gradient\") plt.colorbar() plt.show() In\u00a0[16]: Copied! <pre>losshistory = []\nreconstructions = []\nnum_steps = 100\n\n# Define optimizer\ninit_fun, update_fun, get_params = optimizers.adam(0.1, 0.9, 0.9)\nopt_state = init_fun(params)\n\n# Define and compile the update function\n@jit\ndef update(opt_state, key, k):\n    v = get_params(opt_state)\n    src_num = random.choice(key, num_sources)\n    lossval, gradient = loss_with_grad(v, src_num)\n    gradient = smooth_fun(gradient)\n    return lossval, update_fun(k, gradient, opt_state)\n\n\n# Main loop\npbar = tqdm(range(num_steps))\n_, key = random.split(random_seed)\nfor k in pbar:\n    _, key = random.split(key)\n    lossval, opt_state = update(opt_state, key, k)\n\n    ## For logging\n    new_params = get_params(opt_state)\n    reconstructions.append(get_sound_speed(new_params).on_grid)\n    losshistory.append(lossval)\n    pbar.set_description(\"Loss: {}\".format(lossval))\n</pre> losshistory = [] reconstructions = [] num_steps = 100  # Define optimizer init_fun, update_fun, get_params = optimizers.adam(0.1, 0.9, 0.9) opt_state = init_fun(params)  # Define and compile the update function @jit def update(opt_state, key, k):     v = get_params(opt_state)     src_num = random.choice(key, num_sources)     lossval, gradient = loss_with_grad(v, src_num)     gradient = smooth_fun(gradient)     return lossval, update_fun(k, gradient, opt_state)   # Main loop pbar = tqdm(range(num_steps)) _, key = random.split(random_seed) for k in pbar:     _, key = random.split(key)     lossval, opt_state = update(opt_state, key, k)      ## For logging     new_params = get_params(opt_state)     reconstructions.append(get_sound_speed(new_params).on_grid)     losshistory.append(lossval)     pbar.set_description(\"Loss: {}\".format(lossval)) <pre>Loss: 0.049446240067481995: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [01:48&lt;00:00,  1.09s/it]\n</pre> <p>Finally, let's look at the reconstructed image and its evolution during the optimization</p> In\u00a0[17]: Copied! <pre>from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\nimport matplotlib.font_manager as fm\n</pre> from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar import matplotlib.font_manager as fm In\u00a0[25]: Copied! <pre>sos_original = get_sound_speed(params).on_grid\ntrue_sos = sound_speed.on_grid\nvmin = np.amin(true_sos)\nvmax = np.amax(true_sos)\n\nfig, axes = plt.subplots(2, 4, figsize=(10, 5.5))\n\nk = 0\nrecs = [24, 39, 69, 99]\nfor row in range(2):\n    for col in range(4):\n        if k == 0:\n            axes[row, col].imshow(true_sos, cmap=\"inferno\", vmin=vmin, vmax=vmax)\n            axes[row, col].scatter(\n                sensors_positions[1],\n                sensors_positions[0],\n                c=\"g\",\n                marker=\".\",\n                label=\"sensors\",\n            )\n            axes[row, col].legend(loc=\"lower right\")\n            axes[row, col].set_title(\"True speed of sound\")\n            axes[row, col].set_axis_off()\n        elif k == 1:\n            im_original = axes[row, col].imshow(sos_original, cmap=\"inferno\", vmin=vmin, vmax=vmax)\n            axes[row, col].set_axis_off()\n            axes[row, col].set_title(\"Initial guess\")\n            \n            cbar_ax = fig.add_axes([0.53, 0.54, 0.01, 0.385])\n            cbar = plt.colorbar(im_original, cax=cbar_ax)\n            cbar.ax.get_yaxis().labelpad = 15\n            cbar.ax.set_ylabel('m/s', rotation=270)\n        elif k == 2:\n            axes[row, col].set_axis_off()\n        elif k == 3:\n            axes[row, col].plot(losshistory)\n            axes[row, col].set_title(\"Loss\")\n            #axes[row, col].set_xticks([], [])\n            axes[row, col].margins(x=0)\n        else:\n            axes[row, col].imshow(reconstructions[recs[k - 4]], cmap=\"inferno\", vmin=vmin, vmax=vmax)\n            axes[row, col].set_axis_off()\n            axes[row, col].set_title(\"Step {}\".format(recs[k - 4] + 1))\n        k += 1\n\n# Scale bar\nfontprops = fm.FontProperties(size=12)\nscalebar = AnchoredSizeBar(\n    axes[-1, -1].transData,\n    100, '1 cm', 'lower right', \n    pad=0.3,\n    color='white',\n    frameon=False,\n    size_vertical=2,\n    fontproperties=fontprops)\naxes[-1, -1].add_artist(scalebar)\n        \nfig.tight_layout()\n\nplt.savefig('fwi.pdf')\n</pre> sos_original = get_sound_speed(params).on_grid true_sos = sound_speed.on_grid vmin = np.amin(true_sos) vmax = np.amax(true_sos)  fig, axes = plt.subplots(2, 4, figsize=(10, 5.5))  k = 0 recs = [24, 39, 69, 99] for row in range(2):     for col in range(4):         if k == 0:             axes[row, col].imshow(true_sos, cmap=\"inferno\", vmin=vmin, vmax=vmax)             axes[row, col].scatter(                 sensors_positions[1],                 sensors_positions[0],                 c=\"g\",                 marker=\".\",                 label=\"sensors\",             )             axes[row, col].legend(loc=\"lower right\")             axes[row, col].set_title(\"True speed of sound\")             axes[row, col].set_axis_off()         elif k == 1:             im_original = axes[row, col].imshow(sos_original, cmap=\"inferno\", vmin=vmin, vmax=vmax)             axes[row, col].set_axis_off()             axes[row, col].set_title(\"Initial guess\")                          cbar_ax = fig.add_axes([0.53, 0.54, 0.01, 0.385])             cbar = plt.colorbar(im_original, cax=cbar_ax)             cbar.ax.get_yaxis().labelpad = 15             cbar.ax.set_ylabel('m/s', rotation=270)         elif k == 2:             axes[row, col].set_axis_off()         elif k == 3:             axes[row, col].plot(losshistory)             axes[row, col].set_title(\"Loss\")             #axes[row, col].set_xticks([], [])             axes[row, col].margins(x=0)         else:             axes[row, col].imshow(reconstructions[recs[k - 4]], cmap=\"inferno\", vmin=vmin, vmax=vmax)             axes[row, col].set_axis_off()             axes[row, col].set_title(\"Step {}\".format(recs[k - 4] + 1))         k += 1  # Scale bar fontprops = fm.FontProperties(size=12) scalebar = AnchoredSizeBar(     axes[-1, -1].transData,     100, '1 cm', 'lower right',      pad=0.3,     color='white',     frameon=False,     size_vertical=2,     fontproperties=fontprops) axes[-1, -1].add_artist(scalebar)          fig.tight_layout()  plt.savefig('fwi.pdf') <pre>/tmp/ipykernel_861312/10384555.py:58: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.\n  fig.tight_layout()\n</pre>"},{"location":"notebooks/time_varying/FWI.html#full-wave-inversion","title":"Full Wave Inversion\u00b6","text":"<p>This tutorial shows how to developa (very idealized) Full Waveform Inversion algorithms with <code>jwave</code>. To highlight the ability of customizing the inversion algorithm, we'll add a smoothing step to the gradient computation before performing the gradient descent step with the Adam optimizer.</p>"},{"location":"notebooks/time_varying/FWI.html#setup-simulation","title":"Setup simulation\u00b6","text":"<p>Let's start by importing the required modules</p>"},{"location":"notebooks/time_varying/FWI.html#run-the-simulation","title":"Run the simulation\u00b6","text":"<p>At this point, we can finally use the <code>simulate_wave_propagation</code> to compute the wave propagation, with the given sound speed map and a pulse transmitted from the requested sensor.</p>"},{"location":"notebooks/time_varying/FWI.html#define-the-optimization-problem","title":"Define the optimization problem\u00b6","text":"<p>We'll let <code>autodiff</code> generate the full wave inversion algorithm. To do so, we need to specify a forward model that maps the speed of sound map to the acoustic data.</p> <p>While this has already be done in the previous cells of this notebook, we'll wrap it around a new function used to reparametrize the speed of sound map. This is done because the forward simulation is unstable for speed of sound values below a certain treshold $T$. To make sure that such maps are not in the range of the inversion algorithm, the speed of sound map is parametrized as $$ c = T + \\text{sigmoid}(c') $$</p> <p>Also, we'll mask the pixels outside the circle defined by the sensors, since we know that the only unknowns are the pixel values inside of it.</p> <p>Lastly, we also define a handy initialization function that defines a over-smoothed version of the true sound speed map as initial guess</p>"},{"location":"notebooks/time_varying/FWI.html#minimize-the-objective-function","title":"Minimize the objective function\u00b6","text":"<p>Equipped with a function that calculates the correct gradients, we can finally run the FWI algorithm by randomly looping trough the sources and update the speed of sound estimate.</p> <p>Following the spirit of <code>JAX</code>, all that is needed to do is to write an <code>update</code> function that calculates the gradients and applies a step of the optimization algorithm (but we could have used full batch methods, such as BFGS). In this function, we'll also smooth the gradients: this is not necessarily a smart thing to do, but we use it here to highlight how the user can customize any step of the algorithms developed using <code>jwave</code>.</p>"},{"location":"notebooks/time_varying/FWI.html#note","title":"Note\u00b6","text":"<p>This notebook is only intended to highlight the ability to take gradients using a discretize-then-optimize  approach (see also [Burstedde  2009], [Guidio 2021] and [Rackauckas 2021].</p> <p>We are also guilty of committing the inverse crime, since the same simulator has been used to both generate the data and inverting them.</p>"},{"location":"notebooks/time_varying/point_sources.html","title":"Point sources","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom jax import jit\nfrom jaxdf import FourierSeries\nfrom matplotlib import pyplot as plt\n\nfrom jwave.acoustics import simulate_wave_propagation\nfrom jwave.geometry import *\nfrom jwave.signal_processing import analytic_signal, apply_ramp, gaussian_window, smooth\nfrom jwave.utils import show_field, show_positive_field\n\ndomain = Domain((128, 128), (0.1e-3, 0.1e-3))\n</pre> import numpy as np from jax import jit from jaxdf import FourierSeries from matplotlib import pyplot as plt  from jwave.acoustics import simulate_wave_propagation from jwave.geometry import * from jwave.signal_processing import analytic_signal, apply_ramp, gaussian_window, smooth from jwave.utils import show_field, show_positive_field  domain = Domain((128, 128), (0.1e-3, 0.1e-3)) In\u00a0[2]: Copied! <pre>density = np.ones(domain.N) * 1000\ndensity[50:90, 65:100] = 2300\ndensity = FourierSeries(np.expand_dims(density, -1), domain)\n\nshow_positive_field(density)\n</pre> density = np.ones(domain.N) * 1000 density[50:90, 65:100] = 2300 density = FourierSeries(np.expand_dims(density, -1), domain)  show_positive_field(density) In\u00a0[3]: Copied! <pre>medium = Medium(domain=domain, sound_speed=1500.0, density=density)\ntime_axis = TimeAxis.from_medium(medium, cfl=0.3)\n</pre> medium = Medium(domain=domain, sound_speed=1500.0, density=density) time_axis = TimeAxis.from_medium(medium, cfl=0.3) In\u00a0[4]: Copied! <pre>t = jnp.arange(0, time_axis.t_end, time_axis.dt)\ns = jnp.sin(2 * jnp.pi * 4e6 * t)\ns1 = gaussian_window(s, t, 2e-6, 4e-7)\ns2 = gaussian_window(s, t, 5e-6, 4e-7)\n\nplt.plot(s1)\nplt.plot(s2)\n</pre> t = jnp.arange(0, time_axis.t_end, time_axis.dt) s = jnp.sin(2 * jnp.pi * 4e6 * t) s1 = gaussian_window(s, t, 2e-6, 4e-7) s2 = gaussian_window(s, t, 5e-6, 4e-7)  plt.plot(s1) plt.plot(s2) Out[4]: <pre>[&lt;matplotlib.lines.Line2D at 0x7efeb845be80&gt;]</pre> In\u00a0[5]: Copied! <pre>from jwave.geometry import Sources\n\nsources = Sources(\n    positions=((28, 64), (32, 32)),\n    signals=jnp.stack([s1, s2]),\n    dt=time_axis.dt,\n    domain=domain,\n)\n</pre> from jwave.geometry import Sources  sources = Sources(     positions=((28, 64), (32, 32)),     signals=jnp.stack([s1, s2]),     dt=time_axis.dt,     domain=domain, ) In\u00a0[6]: Copied! <pre>@jit\ndef compiled_simulator(sources):\n    return simulate_wave_propagation(medium, time_axis, sources=sources)\n</pre> @jit def compiled_simulator(sources):     return simulate_wave_propagation(medium, time_axis, sources=sources) In\u00a0[7]: Copied! <pre>pressure = compiled_simulator(sources)\n</pre> pressure = compiled_simulator(sources) In\u00a0[8]: Copied! <pre>t = 300\nshow_field(pressure[t])\nplt.title(f\"Pressure field at t={time_axis.to_array()[t]}\")\n</pre> t = 300 show_field(pressure[t]) plt.title(f\"Pressure field at t={time_axis.to_array()[t]}\") Out[8]: <pre>Text(0.5, 1.0, 'Pressure field at t=5.999999757477781e-06')</pre>"},{"location":"notebooks/time_varying/point_sources.html#point-sources","title":"Point sources\u00b6","text":""},{"location":"notebooks/time_varying/point_sources.html#medium-properties","title":"Medium properties\u00b6","text":""},{"location":"test_reports/index.html","title":"Index","text":"<p>This directory is populated when the docs are built, and contains information about the tests.</p>"}]}